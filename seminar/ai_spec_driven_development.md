# AI開発手法セミナー：仕様書ベース開発で効率化

## セミナー概要

**テーマ**: AI開発手法で仕様書を作成して開発を進める
**時間**: 45分
**対象者**: Vibe Codingを進めたことがある開発者
**核心メッセージ**:
1. 仕様書 = 意思決定の場（AIへの丸投げは失敗する）
2. 自動化パイプラインで品質保証（人間が触らないファイル）
3. フェーズ分離で効率化（計画と実装を明確に分ける）
4. AI協働で仕様書作成スキルが向上（レビューを通じて学習・成長）

---

## Part 1: 問題提起（0-5分）

### そもそもの問題：仕様を明確にしない開発文化

#### よくある開発の現場
- 「とりあえず作ってみよう」で突っ走る
- 要望だけで仕様が明確になっていない
- 「作りながら考える」スタイル
- 開発中に「あれ？これってどうするんだっけ？」が頻発

#### なぜ危険なのか

> **仕様が明確でない = ゴールが定まっていない**

- 開発中に方針がブレる
- 手戻りが多発（「やっぱりこうしよう」）
- 完成したけど要件を満たしていない
- チームメンバー間での認識齟齬

**→ これは人間同士の開発でも問題。AIを使うとさらに悪化する**

### なぜVibe Codingでは限界があるのか

#### Vibe Codingの実態
- 仕様が曖昧なまま100-300文字の雑なプロンプトで開発を依頼
- AIが自由に解釈して実装
- 小規模な改善には有効だが、大規模開発では意図したものができない

#### Vibe Codingでよく起きる失敗パターン

> **これらは仕様書がないことで発生する問題です**

**1. 技術選定を任せる危険性**
- 具体例：SWRを全CRUD操作に使用しようとした事例
- CRUDの4つのうち、SWRが最適化されているのはRead（データ取得）のみ
- Create/Update/Deleteの3/4は本来の用途から外れている
- 人間なら「複雑になるならAxiosを使う」と判断できるが、AIは統一性を重視してしまう

**2. 型定義の齟齬問題**
- Vibe Codingでは各環境で独立して型定義を生成
- フロントエンドとバックエンドで型定義がずれる
- バックエンドの変更がフロントエンドに反映されない
- 参照エラーが頻発

**3. プロジェクト構造の把握不足**
- Vibe Codingではプロジェクトのドメイン知識が伝わらない
- `/api`プロキシ設定を無視してハードコード
- 環境設定や開発ルールが暗黙知として共有されているが、AIには伝わらない

#### Vibe Codingの根本的な問題：意思決定の不在

> **人間が行うべき意思決定をAIに委ねてしまっている**

**二重の問題構造**:
1. **仕様が明確でない**（人間が決めていない）
2. **曖昧なまま AIに丸投げ**（AIが勝手に解釈）

**なぜAIでは特に危険か**:
- AIには経験に基づく技術的判断が不足
- 暗黙知（業界標準、ベストプラクティス）の理解が限定的
- 文脈を理解した柔軟な修正ができない
- **人間なら「これ、仕様決まってないですよね？」と気づけるが、AIは黙って実装してしまう**

#### なぜ仕様書を書かないのか：仕様書アレルギーの原因

> Vibe Codingに頼ってしまう背景には、仕様書に対する心理的な障壁があります

1. **良い仕様書のお手本がない**
   - 仕様書を読み込んだ経験が少ない
   - 完璧な仕様書を書ける人は稀
   - 「どう書けばいいか分からない」という不安

2. **レビュープロセスの不在**
   - 仕様書のレビューアーを確保するのが困難
   - フィードバックを得る機会が少ない
   - 書いても誰も見てくれない

3. **時間コストの高さ**
   - 仕様書作成に時間がかかると感じている
   - 完璧を求めすぎて手が止まる
   - 「書くより作った方が早い」と感じてしまう

**→ だからVibe Codingに頼ってしまう。しかし、それでは大規模開発は失敗する**

#### 問題の構造をまとめると

<!-- 🎨 図解1: 問題の連鎖フロー図 -->
```
仕様を明確にしない文化
    ↓
要望だけで突っ走る
    ↓
Vibe Codingで雑なプロンプト
    ↓
AIが自由に解釈して実装
    ↓
意図したものができない
```

**解決策: 仕様書ベース開発 + 自動化パイプライン**

---

## Part 2: 3フェーズ開発手法（5-15分）

### 解決策：計画・実装・検証の明確な分離

#### 全体フロー

<!-- 🎨 図解2: 3フェーズ開発の全体フロー図（循環型） -->
```
Phase 1: 計画フェーズ（docs/）
  ↓ 仕様書作成・レビュー
  ↓ AIと協働で仕様書を作成
  ↓ 人間が意思決定

Phase 2: 実装フェーズ（application/）
  ↓ 仕様書に基づいて実装
  ↓ AIが実行を担当
  ↓ 人間が監視・修正

Phase 3: 検証フェーズ
  ↓ 計画と実装の差分分析
  ↓ 仕様漏れの特定
  ↓ 知見の蓄積
```

### Phase 1: 計画フェーズ

#### 目的
- 何を作るか、どのような方針で開発するかを決定する
- **人間が意思決定を行い、AIがドキュメント化を支援**

#### やること
- 型定義の設計
- データベース構造の設計
- API仕様の定義
- アーキテクチャ設計
- 機能要件・非機能要件の明確化

#### やらないこと（重要）
- ❌ 実装コードの記述禁止
- ❌ 具体的なロジックの記述禁止
- ❌ ライブラリの選定禁止
- ❌ 具体的な関数実装禁止

#### AIとの協働フロー

1. **要件の整理**: 何を作りたいかを箇条書きで整理
2. **AIとの対話**: 仕様書の作成を依頼
3. **レビューと修正**: 作成された仕様書を人間の視点でレビュー
4. **反復改善**: 不足部分や曖昧な部分を繰り返し修正

#### プロンプト例（CLAUDE.md）

**設計フェーズのルール要点**:
- 目的：人間の意図を適切に伝える
- 行うこと：型定義、DB構造、API仕様、アーキテクチャ設計
- 禁止事項：実装コード・ロジック・ライブラリ選定

> **詳細は参考記事**: [AI協働で仕様書アレルギー克服！](https://tech-lab.sios.jp/archives/49148)

### Phase 2: 実装フェーズ

#### 役割分担
- **人間の役割**: 監視役に徹し、暴走時に小さなプロンプトで修正
- **AIの役割**: 定義された仕様書に従って実装

#### 重要ポイント
- 説明は全て計画フェーズで作った仕様書に含まれている
- 仕様書を入力として与えるだけで実装が進む

### Phase 3: 検証フェーズ

#### 目的
- 仕様書の不備を特定し、次回の改善につなげる
- 根拠のない編集を防止

#### やること
1. **計画と実装の差分分析**
   - 仕様書に書いていなかった実装を特定
   - 実装中に追加された機能や変更を洗い出し

2. **仕様漏れの特定**
   - バグではなく仕様漏れが圧倒的に多い
   - テスト中に気づいた不足部分を記録

3. **知見の蓄積**
   - 得られた知見を次回プロジェクトに活用
   - 計画ドキュメントを改善

#### 検証プロンプト例

```text
計画ドキュメントと実装の内容を確認して、
計画と実装の差異がある点をまとめてください。
```

### 実際の開発効果：驚異的な時間短縮

#### 小規模システムの例
- バックエンドのエンドポイント2つ
- フロントエンドの画面1つ
- **開発時間：約30分で完了**

#### Before/After比較

<!-- 🎨 図解3: Before/After比較図（グラフ形式） -->
| 項目 | Before（従来の人間だけでの開発） | After（AI協力した仕様書駆動） |
|------|----------------------------------|-------------------------------|
| 仕様検討 | 開発中に随時（割り込み多数） | 事前に1-2時間 |
| 開発時間 | 1週間 | 2日 |
| 手戻り回数 | 平均3-4回 | 平均1回 |

#### 数値で見る効果
- 開発時間: **1週間 → 2日（71%削減）**
- 手戻り: **平均3-4回 → 1回（75%削減）**

### 🌱 副次的効果：エンジニアとしての成長

#### 1. 仕様書作成スキルの向上
- AIが返す仕様書を見て「分かりやすい」と感じる体験
- 良い仕様書の構造やフォーマットを学べる
- 仕様書が苦手な人でも、AIと協働することで形を学べる

#### 2. レビュー観点の育成
- 仕様書の段階で、意図が適切に伝わっているか確認
- 検討不足や考慮不足を事前に発見
- 検証フェーズで計画の不備を分析 → レビュー観点が育つ

#### 3. 設計思考の強化
- 開発前に作成したい機能を整理する習慣
- アーキテクチャ全体を俯瞰する視点
- 技術的な意思決定の経験蓄積

> **学習的な側面でも価値がある**
> 完璧な仕様書は存在しないが、機能ごとに段階的に作っていくアプローチで継続的に改善できる

---

## Part 3: 自動化パイプラインで品質保証（15-30分）

### なぜ自動化パイプラインが必要か

#### 問題：型定義の齟齬
- フロントエンドとバックエンドで型定義がずれる
- バックエンドの型定義変更がフロントエンドに反映されない
- AIは各環境で独立して型定義を生成してしまう
- 人間なら「バックエンドで型が変わったから更新しなきゃ」と気づけるが、AIは各ファイルを独立して見る

#### 解決策：人間もAIも触らないファイルを作成

```
バックエンド（Nest.js）
    ↓ 自動生成
OpenAPI Spec
    ↓ 自動生成（Orval）
フロントエンド型定義（Next.js）
```

### 自動生成パイプラインの構築

<!-- 🎨 図解4: 自動生成パイプライン図（矢印フロー） -->
#### 自動生成の流れ

```
バックエンド（Nest.js）
    ↓ 自動生成
OpenAPI Spec
    ↓ Orval
フロントエンド型定義（Next.js）
```

#### 1. OpenAPI Spec自動生成

**Nest.jsからOpenAPI Spec**を自動生成する仕組みを導入
- バックエンドのAPI仕様が変更されると、自動的にスペックファイルも更新
- Nest.js公式で提供されているので、コードレベルでOpenAPI Specを生成可能

#### 2. フロントエンド側の自動生成

**Orvalを使用して、Next.jsに型定義とAPI関数を自動生成**

- OpenAPI Specから型定義とAxios関数を自動生成
- バンドルサイズを20-30%削減
- フロントとバックの型整合性を機械的に保証

> **詳細は参考記事**: [Orval SWRの自動生成をやめた理由 – SWRの本質を見失っていた話](https://tech-lab.sios.jp/archives/49591)

#### 3. Claudeへの通知

最も重要なのは、**Claudeに変更不可と明確に通知**すること

- 自動生成されるファイルには「DO NOT EDIT – Auto Generated」のコメント
- CLAUDE.mdファイルで「このファイルは自動生成されるため変更禁止」と明記
- 自動生成するためのコマンドを明確に指定

### パーツ提供の思想

#### 品質保証としてのパーツ化

個々のコンポーネントの品質がシステム全体に与える影響は重大
- 一つのコンポーネントに不具合があると、システム全体の信頼性を損なう
- 基盤となるパーツがすべて品質に問題を抱えている場合は深刻

#### 役割分担

<!-- 🎨 図解5: 役割分担図（3層構造） -->
**人間の役割**:
- 作成すべき機能と要件を明確に定義する
- 使用するパーツの選択と品質基準の設定
- パーツの妥当性と整合性を検証する

**パーツ/自動生成の役割**:
- 実装方法を標準化し、一貫性を保つ
- コードの品質を一定レベルに維持する
- 再利用性を高め、開発効率を向上させる

**AIの役割**:
- 定義されたパーツを適切に組み合わせて実装する
- ボイラープレートコードの大量生成を効率化
- 人間が決定した設計方針に従ってコードを構築する

#### 実例：自動生成パイプライン

**重要なポイント**:
- バックエンドのDTO定義（設計判断）は人間が行う
- 型定義とAPI関数の生成は自動化
- 設計の一貫性を保ちながら実装効率を大幅に向上

> **詳細は参考記事**: [AIと爆速開発！Next.js×Nest.js型定義同期の自動生成パイプライン構築術](https://tech-lab.sios.jp/archives/49157)

#### 参考事例：Shadcn/uiのアプローチ

Shadcn/uiが革新的な点：
- UIコンポーネントを標準化された「パーツ」として提供
- 開発者が「どのコンポーネントを使用するか」という意思決定に集中
- AIは「パーツを選択して適切に組み合わせる」作業に集中
- 結果として開発効率と品質の両立を実現

この考え方は、API接続層やビジネスロジック層にも応用可能

### 実際の効果

**型定義の不整合が完全に解消**:
- バックエンドを定義したら、フロントエンドを並行して開発可能
- 型定義の齟齬がほとんどなくなった
- フロント側での型定義の再定義が不要に

**プロジェクト全体の品質向上**:
- バンドルサイズ20-30%削減
- より整理されたファイル構造
- 可読性が向上

---

## Part 4: 実践の勘所（30-40分）

### 意思決定を握る3原則

<!-- 🎨 図解7: 3原則の循環図 -->
#### 原則1：計画ドキュメントでの明文化

**実施内容**:
- 技術選定の理由を具体的かつ詳細に文書化
- 実装方針を明確で実行可能なレベルまで記述
- 暗黙知となっている判断基準の言語化

**明文化の範囲について**:
- コンテキスト量の制約を考慮（トークン制限）
- バランス調整は現在の技術的制約として受け入れる

**実践的な運用方法**:
- バックエンドとフロントエンドを並行開発する場合、ToDo形式で管理
- 進捗を可視化することで、AIツールが停止した場合も明確な再開ポイントを確保

#### 原則2：パーツによる実行の標準化

**実施内容**:
- 再利用可能なコンポーネント・関数の設計と整備
- API接続の標準化（型定義、エラーハンドリング含む）
- 開発ツール（Linter、Formatter等）の統一と自動化

**品質保証の重要性**:
- 個々のパーツの品質は、システム全体の安定性に直結
- パーツ設計段階での品質基準の設定と検証が不可欠

#### 原則3：検証による継続的改善

**実施内容**:
- 計画と実装結果の差分分析と記録
- 発見された問題点や改善点の体系的な蓄積
- 得られた知見の次回プロジェクトへの適用

**現実的な視点の重要性**:
- 完璧な計画ドキュメントを最初から作成することは現実的ではない
- 開発過程で「より良いアプローチが明確になる」ことは自然
- 変更の必要性を適切に判断し、修正された方針で実装を完了
- 完了後には差分を分析し、その経験を将来のプロジェクトに活かす

### プロジェクト構成の最適化

#### ディレクトリ構造

<!-- 🎨 図解6: プロジェクト構成図（ディレクトリツリー） -->
```
/
├── CLAUDE.md                    # プロジェクト全体のガイドライン
├── docs/                        # 計画・設計フェーズ
│   ├── CLAUDE.md                # 計画フェーズ専用ルール
│   ├── features/                # 新機能計画
│   ├── bugs/                    # バグ調査・修正計画
│   └── research/                # 検証結果・知見
└── application/                 # 実装フェーズ
    ├── backend/
    │   └── CLAUDE.md            # バックエンド実装ルール
    └── frontend/
        └── CLAUDE.md            # フロントエンド実装ルール
```

#### 各フェーズ用のCLAUDE.mdファイル配置

各ディレクトリにCLAUDE.mdファイルを配置し、そのディレクトリ固有のルールを記載
- フロントエンド: 自動生成ファイルの変更禁止、ライブラリ制限
- バックエンド: API仕様変更手順、DBスキーマ変更ルール
- docs: ドキュメント作成フォーマット、必須項目

#### AIに触らせないファイルの明確化

**ファイル管理戦略**:
- 自動生成ファイル: 「DO NOT EDIT – Auto Generated」コメント付与
- 変更不可ファイルをCLAUDE.mdにリスト化

**注意**: AIは時々無視するので、無視されたら即座に指摘

### 仕様書の適切な分量バランス

#### 長すぎるとAIが無視する
- 「無視しました」という返答が返ってくることもある
- 短ければ理想的だが、短すぎると時間がかかる
- AIが無視する可能性も考慮しながら適切な分量を見極める

#### どの程度の分量が適切か

**プロジェクト依存**:
- ドメイン知識が多ければ、仕様書に書く情報は少なくて済む
- 元のコンテキスト量が影響する

**具体的な目安**:
- エンドポイント2つ + 対応する画面1つ程度
- 体感的に上手くいった印象

### 仕様書ベース開発で陥る3つの落とし穴

#### 落とし穴1：ドメイン知識の明示化不足

**問題**: `/api`プロキシ設定など、暗黙知がAIに伝わらない
**対策**: プロジェクトコアドキュメントで環境設定・ルールを明文化

#### 落とし穴2：AIがドキュメントを無視する

**問題**: CLAUDE.mdを書いても時々無視される
**対策**:
- 最重要な制約はドキュメント + プロンプトで二重に指示
- 無視されたら即座に指摘して修正

#### 落とし穴3：仕様書の分量バランスミス

**問題**: 長すぎると無視され、短すぎると時間がかかる
**対策**: エンドポイント2つ + 画面1つ程度の粒度が目安

> **詳細は参考記事**: [Claude Code仕様書ベースでハマる6つの落とし穴！](https://tech-lab.sios.jp/archives/49154)

### AIから学ぶ実践テクニック

**AIと協働することで得られる3つの学習効果**:
1. **仕様書スキル**: AIが返す仕様書から構造・フォーマットを学ぶ
2. **レビュー観点**: 不足箇所に気づく感覚、設計整合性の確認視点
3. **意思決定力**: 技術選定の言語化、トレードオフ思考の訓練

---

## Part 5: まとめ（40-45分）

### 重要ポイントの整理

#### 1. 技術選定の主導権確保
- AIに技術的判断を委ねることのリスク
- 経験に基づく適切な技術選択の重要性

#### 2. 計画ドキュメントによる意思決定の明文化
- 暗黙知の言語化
- 全ての判断基準の明確化の必要性

#### 3. 意思決定と実行の明確な分離
- 人間とAIの適切な役割分担による効率化の実現

#### 4. パーツ化による実行の標準化
- 品質保証と再利用性向上のための設計アプローチ

#### 5. 継続的改善による知見の蓄積
- 完璧性よりも学習と改善を重視したアプローチ

### 結論

現在のAI協働開発においては、**人間が意思決定を行い、AIが実行を担当する**という役割分担が最も効果的

**人間の強み**:
- 経験に基づく技術的判断
- コンテキストを考慮した柔軟な意思決定

**AIの強み**:
- 高速で大量のコード生成
- 定められたパターンに従った正確な実装

### 効率化 + 成長の二重効果

<!-- 🎨 図解8: 二重効果の対比図 -->
#### 効率化の効果
- 開発時間: 1週間 → 2日（71%削減）
- 手戻り: 平均3-4回 → 1回（75%削減）
- バンドルサイズ: 20-30%削減
- 実装時間: 14-20時間見積もり → 4.2時間で完了（21-30%効率化）

#### 成長の効果
- 仕様書作成スキルの向上
- レビュー観点の育成
- 設計思考の強化
- 技術的意思決定の経験蓄積

### 今日から始める3ステップ

<!-- 🎨 図解9: 3ステップの階段図 -->
#### Step 1: 小さく始める
- まず1つの機能で試してみる
- 計画ドキュメントを作成してAIにレビューしてもらう
- 完璧を求めず、まずは形を作る

#### Step 2: 自動化パイプラインを導入
- OpenAPI Specの自動生成を設定
- Orvalで型定義の自動生成を構築
- CLAUDE.mdで変更不可ファイルを明示

#### Step 3: 継続的に改善
- 計画と実装の差分を分析
- 発見した問題点をドキュメントに反映
- 次回のプロジェクトで改善を適用

### 実践への提案

AI協働開発を検討されている方は、まず「計画ドキュメント」の作成から始めることをお勧めします

- 初期段階では作成コストが高く感じられるかもしれない
- 中長期的には開発効率と成果物の品質において大幅な改善効果が期待できる

この記事で紹介した3原則と実践的アプローチが、皆さんのAI協働開発プロジェクトの成功に寄与できれば幸いです

---

## Q&A

### よくある質問

**Q1: 既存プロジェクトにも適用できますか？**
A1: はい。既存コードのドキュメント化から始めて、新機能追加時に3フェーズ開発を導入するのが効果的です。

**Q2: 仕様書作成に時間がかかりすぎませんか？**
A2: 初回は時間がかかりますが、実装中の手戻りが減るため、トータルでは時間短縮になります。2回目以降はテンプレートを再利用できます。

---

## 参考資料

### ブログ記事（SIOS Tech Lab）

#### 3フェーズ開発手法
- [Claude Code革命！3フェーズ開発で効率的な開発：計画→実装→検証術](https://tech-lab.sios.jp/archives/49140)
- [AI協働で仕様書アレルギー克服！開発時間を1週間→2日に短縮する実践法](https://tech-lab.sios.jp/archives/49148)
- [Claude Code仕様書ベースでハマる6つの落とし穴！失敗回避の備忘録](https://tech-lab.sios.jp/archives/49154)

#### 自動化パイプライン
- [AIと爆速開発！Next.js×Nest.js型定義同期の自動生成パイプライン構築術](https://tech-lab.sios.jp/archives/49157)
- [Orval SWRの自動生成をやめた理由 – SWRの本質を見失っていた話](https://tech-lab.sios.jp/archives/49591)

#### 実践知見
- [AI協働開発の落とし穴回避！3ヶ月で実証した計画ドキュメントの価値](https://tech-lab.sios.jp/archives/49594)
- [「適当にプロンプト投げるだけ」を卒業！Vibe Coding脱却術](https://tech-lab.sios.jp/archives/49136)

### 外部リソース
- [GitHub Spec Kit](https://github.blog/ai-and-ml/generative-ai/spec-driven-development-with-ai-get-started-with-a-new-open-source-toolkit/) - 仕様駆動開発のツールキット
- [Orval - OpenAPI to TypeScript](https://orval.dev/) - OpenAPIから型定義を自動生成
- [Kiro IDE (AWS)](https://kiro.dev/) - Spec Mode搭載のAI IDE
