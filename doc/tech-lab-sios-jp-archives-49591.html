<h1>Orval SWRの自動生成をやめた理由 – SWRの本質を見失っていた話 | SIOS Tech. Lab</h1>


	
<div data-smooth-scroll="1" data-smooth-scroll-offset="24"><div><div><b>目次</b></div><div><ul><li><a href="#chumeni"><span>1</span><span>初めに</span></a></li><li><a href="#TLDR"><span>2</span><span>TL;DR</span></a></li><li><a href="#wen_tino_fa_jian_bian_lisugiru_zi_dong_sheng_chengno_min"><span>3</span><span>問題の発見：便利すぎる自動生成の罠</span></a></li><li><a href="#SWRno_ben_zhiwo_jiantsume_zhisu"><span>4</span><span>SWRの本質を見つめ直す</span></a></li><li><a href="#BeforeAfter_Orval_she_dingno_bian_geng"><span>5</span><span>Before/After: Orval設定の変更</span></a><ul><li><a href="#Before_jiu_she_ding"><span>5.1</span><span>Before（旧設定）</span></a></li><li><a href="#After_xin_she_ding"><span>5.2</span><span>After（新設定）</span></a></li></ul></li><li><a href="#zi_dong_sheng_chengno3tsuno_wen_ti"><span>6</span><span>自動生成の3つの問題</span></a><ul><li><a href="#1_bu_yaonaobaheddo"><span>6.1</span><span>1. 不要なオーバーヘッド</span></a></li><li><a href="#2_bandorusaizuno_fei_da_hua"><span>6.2</span><span>2. バンドルサイズの肥大化</span></a></li><li><a href="#3_konponento_she_jino_ying_zhi_hua"><span>6.3</span><span>3. コンポーネント設計の硬直化</span></a></li></ul></li><li><a href="#jie_jue_ce_shi_cai_shi_suonoapurochi"><span>7</span><span>解決策：適材適所のアプローチ</span></a><ul><li><a href="#patan1_deta_qu_de_kasutamuSWRfukku"><span>7.1</span><span>パターン1: データ取得（カスタムSWRフック）</span></a></li><li><a href="#patan2_mutation_zhi_jieAxios_hubi_chushi"><span>7.2</span><span>パターン2: mutation（直接Axios呼び出し）</span></a></li></ul></li><li><a href="#yi_xing_zhongni_fa_jianshitabagu"><span>8</span><span>移行中に発見したバグ</span></a></li><li><a href="#yi_xing_jie_guo_shu_zide_jianru_xiao_guo"><span>9</span><span>移行結果：数字で見る効果</span></a><ul><li><a href="#dui_xiang_fan_tongto_xiao_guo"><span>9.1</span><span>対象範囲と効果</span></a></li></ul></li><li><a href="#AI_kai_fawo_xiao_lu_huasurupatsu_ti_gongno_kaoe_fang"><span>10</span><span>AI開発を効率化する「パーツ提供」の考え方</span></a></li><li><a href="#matome_shi_cai_shi_suoga_zhang_qi_dena_bao_shou_xingwo_shengmu"><span>11</span><span>まとめ：適材適所が長期的な保守性を生む</span></a></li><li><a href="#can_kaorisosu"><span>12</span><span>参考リソース</span></a></li></ul></div></div></div><h2><span>初めに</span></h2><p>ども！今月はAI開発にどっぷりな毎日な龍ちゃんです。今回は「<a href="https://tech-lab.sios.jp/archives/49157" target="_blank" rel="noopener" title=""><strong>AIと爆速開発！Next.js×Nest.js型定義同期の自動生成パイプライン構築術</strong></a>」で開発効率を上げたんですが、そこで起きた問題について原因究明と解決策を模索したので解説していこうと思います。</p><h2><span>TL;DR</span></h2><p>Orvalで全APIエンドポイントにSWRフックを自動生成していたんですが、<strong>バンドルサイズの肥大化</strong>と<strong>不要なオーバーヘッド</strong>が問題になってしまいました。</p><p><strong>解決策</strong>: <code>client: "axios-functions"</code> に変更して、Axios関数のみを自動生成。SWRは必要な箇所のみカスタムフック実装する方針に切り替えました。</p><p><strong>結果</strong>: 47ファイルの移行（4.2時間）で、バンドルサイズを20-30%削減できました！</p><hr><h2><span>問題の発見：便利すぎる自動生成の罠</span></h2><p>最初はOrvalで全APIエンドポイントにSWRフックを自動生成する設定にしていました。便利だと思っていたんですよね。型安全だし、統一感もあるし。</p><p>でも2ヶ月ほど経った頃、ふと気づいたんです。バンドルサイズはどんどん肥大化していくし、mutation処理は無駄にSWRを経由しているし、コードは複雑になっていく一方。<strong>何かがおかしい。</strong></p><p>そこで改めて考え直してみました。SWRって、そもそも何のためのツールだったっけ？と。</p><hr><h2><span>SWRの本質を見つめ直す</span></h2><p>SWRは<strong>データ取得（Read）のために設計</strong>されたライブラリです。名前の由来である「stale-while-revalidate」という戦略が示す通り、以下のような特徴があります：</p><ul><li>キャッシュ戦略による高速な表示</li><li>自動再検証（フォーカス時、再接続時など）</li><li>複数コンポーネント間でのデータ共有</li></ul><p>これって、まさにCRUDのRead（データ取得）に最適化された設計なんですよね。</p><p>一方で、<strong>CUD（Create/Update/Delete）はどうでしょうか？</strong><code>useSWRMutation</code> というフックも用意されていますが、よく考えてみると一回限りのmutationにキャッシュ戦略は不要です。フォーム状態との統合も煩雑になりがちでした。</p><p>それなのに、全エンドポイント分のSWRフックを自動生成していたら、本質的には不要なコードが大量に生まれてしまっていたんです。</p><hr><h2><span>Before/After: Orval設定の変更</span></h2><p>それでは、具体的にどう変更したのか見ていきましょう。</p><h3><span>Before（旧設定）</span></h3><div><pre><code>output:
  mode: "split"   # ❌ ラッパー関数が生成される
  client: "swr"   # ❌ SWRフック自動生成
  # ...
</code></pre></div><p><strong>問題点</strong>: 全エンドポイント分のSWRフックが生成され、バンドル肥大化。mutationにも不要なSWRオーバーヘッドが発生していました。</p><h3><span>After（新設定）</span></h3><div><pre><code>output:
  mode: "single"             # ✅ 直接エクスポート
  client: "axios-functions"  # ✅ Axios関数のみ生成
  # ...
</code></pre></div><p><strong>改善点</strong>: Axios関数のみを生成し、SWRは必要な箇所のみ手動で作成。バンドルサイズを20-30%削減できました。</p><p>シンプルですよね。でも、この変更が大きな効果を生んだんです。</p><hr><h2><span>自動生成の3つの問題</span></h2><p>実際に移行作業を進めながら、自動生成のどこが問題だったのか明確になってきました。</p><h3><span>1. 不要なオーバーヘッド</span></h3><p>例えば、投稿を作成する処理を考えてみてください。これって一回限りのアクションですよね。キャッシュも再検証も不要なのに、SWRの状態管理オーバーヘッドが動いている。これは明らかに無駄でした。</p><h3><span>2. バンドルサイズの肥大化</span></h3><p>数字で見ると、問題の大きさがよくわかります：</p><div><figure><table><thead><tr><th>項目</th><th>Before</th><th>After</th><th>改善</th></tr></thead><tbody><tr><td>自動生成フック数</td><td>41個</td><td>0個</td><td>完全削除</td></tr><tr><td>バンドルサイズ</td><td>100%</td><td>70-80%</td><td><strong>20-30%削減</strong></td></tr><tr><td>コード行数</td><td>~2030行</td><td>~800行</td><td><strong>約60%削減</strong></td></tr></tbody></table></figure></div><p>全エンドポイント分のSWRフックが生成されて、使わないものも含めて全部バンドルに入ってしまっていたんですね。</p><h3><span>3. コンポーネント設計の硬直化</span></h3><p>これが一番厄介でした。SWRの状態（<code>isMutating</code>, <code>error</code>）とフォームの状態（<code>isSubmitting</code>, <code>validationErrors</code>）が分裂してしまって、同期が複雑化していたんです。</p><p>実際にフォームを実装していると、「あれ、どっちのエラー状態を見ればいいんだっけ？」みたいなことが頻発していました。</p><hr><h2><span>解決策：適材適所のアプローチ</span></h2><p>そこで、シンプルな方針に切り替えました：</p><div><pre><code>✅ Read（GET） → カスタムSWRフック
✅ CUD（POST/PUT/DELETE） → 直接Axios呼び出し</code></pre></div><p>それぞれ見ていきましょう。</p><h3><span>パターン1: データ取得（カスタムSWRフック）</span></h3><p>データ取得には、SWRの恩恵を最大限活用します。</p><div><pre data-lang="TypeScript"><code>// hooks/useSeriesDrafts.ts
import useSWR from "swr";
import { seriesDraftsControllerFindAll } from "@/lib/api/generated";

/
  シリーズ下書き一覧を取得するカスタムフック
  SWRのキャッシュ・再検証・データ共有の恩恵を受けられる
 /
export const useSeriesDraftsControllerFindAll = () =&gt; {
  return useSWR("/api/series-drafts", () =&gt; seriesDraftsControllerFindAll());
};

// コンポーネントでの使用
const { data, error, isLoading } = useSeriesDraftsControllerFindAll();
</code></pre></div><p>SWRのキャッシュ戦略により、複数のコンポーネントで同じデータを効率的に共有できます。フォーカス時の自動再検証なども自動で行われるので、常に新鮮なデータを表示できるんですよね。</p><h3><span>パターン2: mutation（直接Axios呼び出し）</span></h3><p>一方、データの作成・更新・削除は直接Axiosを呼び出します。</p><div><pre data-lang="TypeScript"><code>import { useState } from "react";
import { mutate } from "swr";
import { seriesDraftsControllerCreate } from "@/lib/api/generated";

const [isCreating, setIsCreating] = useState(false);

/
  シリーズ下書きを作成する処理
  SWRのオーバーヘッドなしで、シンプルに実装できる
 /
const handleCreate = async (data) =&gt; {
  setIsCreating(true);
  try {
    await seriesDraftsControllerCreate(data);
    // 作成後、SWRキャッシュを更新して一覧を再取得
    mutate("/api/series-drafts");
  } finally {
    setIsCreating(false);
  }
};
</code></pre></div><p>このアプローチなら、不要なオーバーヘッドを回避できて、フォーム状態との統合も容易になります。必要に応じて <code>mutate()</code> でSWRキャッシュを更新すれば、一覧表示も自動的に最新化されます。</p><p>シンプルでわかりやすいですよね。</p><hr><h2><span>移行中に発見したバグ</span></h2><p>実は移行作業中に、思わぬバグも見つかりました。</p><p><strong>axiosInstance と axiosClient の混同</strong>: 3つのファイルで <code>axiosClient</code> をAxiosインスタンスとして誤使用していたんです。</p><div><pre data-lang="TypeScript"><code>// ❌ Before（バグ）
import { axiosClient } from "@/lib/axiosClient";
await axiosClient.get("/.auth/me"); // TypeError!

// ✅ After（修正）
import { axiosInstance } from "@/lib/axiosClient";
await axiosInstance.get("/.auth/me");
</code></pre></div><p><strong>教訓</strong>: <code>axiosClient</code> はOrval mutator関数として使うもので、直接HTTP呼び出しには <code>axiosInstance</code> を使用する必要があります。</p><p>命名が似ていると、こういう混同が起きやすいんですよね。移行作業のおかげで、潜在的なバグを早期発見できたのは副次的な効果でした。</p><hr><h2><span>移行結果：数字で見る効果</span></h2><p>実際の移行結果をまとめてみます。</p><h3><span>対象範囲と効果</span></h3><ul><li><strong>47ファイル移行完了</strong>（実装時間: 4.2時間、推定14-20時間 → 21-30%効率化）</li><li><strong>バンドルサイズ20-30%削減</strong>（自動生成フック: 41個 → 0個）</li><li><strong>カスタムフック</strong>: 9個を必要箇所のみ作成</li><li><strong>コード行数</strong>: ~2030行 → ~800行（約60%削減）</li></ul><p>当初は14-20時間かかると見積もっていたんですが、4.2時間で完了できました。Axiosの関数がパーツとして提供されていたおかげで、AIに実装を任せる際もスムーズに進められたんです。</p><hr><h2><span>AI開発を効率化する「パーツ提供」の考え方</span></h2><p>今回の経験で実感したのが、<strong>AI開発を効率化する鍵は「パーツを提供する」という考え方</strong>だということです。</p><p>shadcn/uiが成功しているのも同じ理由ではないでしょうか。コンポーネントをコピペして、必要に応じてカスタマイズできる。全部を自動生成するのではなく、パーツを提供する。</p><p>Axiosのインターフェース部分をパーツとして切り出しておけば、そこに処理を書かせるだけでOK。このアプローチによって、開発効率が飛躍的に向上しました。</p><p>フロントエンドとバックエンドの型の齟齬もなくなりましたし、手が止まることも減りました。すっきりとしたコードで実装できるようになったんです。</p><hr><h2><span>まとめ：適材適所が長期的な保守性を生む</span></h2><p>SWRは素晴らしいツールです。でも、すべてのAPI呼び出しに必要なわけではありません。</p><p><strong>適材適所のアプローチ</strong>:</p><ul><li><strong>データ取得（Read）</strong>: SWRの恩恵を最大限活用</li><li><strong>mutation（CUD）</strong>: シンプルにAxiosで十分</li></ul><p>「便利だから」という理由で全てを自動生成すると、不要な複雑さとバンドル肥大化を招いてしまいます。</p><p>Axiosでパーツのみを提供し、SWRは必要な箇所に手動で適用する。この「適材適所」のアプローチが、長期的な保守性と柔軟性を生むんですね。</p><p>皆さんも、もし自動生成で「何か複雑になってきたな」と感じたら、一度立ち止まって考えてみてください。本質的に必要なものは何か、ツールの設計思想に沿った使い方ができているか。そこを見直すことで、より良い設計にたどり着けるはずです。</p><p>今回の知識を活かして、ぜひ皆さんのプロジェクトでも最適なアプローチを見つけてみてください！</p><hr><h2><span>参考リソース</span></h2><ul><li><a href="https://orval.dev/">Orval</a> – OpenAPI to TypeScript</li><li><a href="https://swr.vercel.app/">SWR</a> – React Hooks for Data Fetching</li><li><a href="https://www.notion.so/research/swr-custom-hooks-migration/README.md">包括的な実装検証ドキュメント</a></li></ul><!-- Anyway Feedback Container //--><div>ご覧いただきありがとうございます！

<span>この投稿はお役に立ちましたか？</span><br><br><a href="#afb-post-49591">役に立った</a><a href="#afb-post-49591">役に立たなかった</a><br><br><span>0人がこの投稿は役に立ったと言っています。</span><input type="hidden" name="post_type" value="post"><input type="hidden" name="object_id" value="49591"></div><!-- //Anyway Feedback Container -->