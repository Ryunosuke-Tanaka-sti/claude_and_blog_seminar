<h1>AIと爆速開発！Next.js×Nest.js型定義同期の自動生成パイプライン構築術 | SIOS Tech. Lab</h1>


	
<div data-smooth-scroll="1" data-smooth-scroll-offset="24"><div><div><b>目次</b></div><div><ul><li><a href="#chumeni"><span>1</span><span>初めに</span></a></li><li><a href="#shi_jini_fa_shengshita_wen_ti_shi_li_xing_ding_yino_ju_yu"><span>2</span><span>実際に発生した問題事例：型定義の齟齬</span></a><ul><li><a href="#huan_jing_gou_cheng"><span>2.1</span><span>環境構成</span></a></li><li><a href="#fa_shengshita_wen_ti"><span>2.2</span><span>発生した問題</span></a></li></ul></li><li><a href="#jie_jue_ce_zi_dong_sheng_chengpaipurainno_gou_zhu"><span>3</span><span>解決策：自動生成パイプラインの構築</span></a><ul><li><a href="#1_OpenAPI_Spec_zi_dong_sheng_cheng"><span>3.1</span><span>1. OpenAPI Spec自動生成</span></a></li><li><a href="#2_furontoendo_ceno_zi_dong_sheng_cheng"><span>3.2</span><span>2. フロントエンド側の自動生成</span></a></li><li><a href="#3_Claude_heno_tong_zhi"><span>3.3</span><span>3. Claude への通知</span></a></li></ul></li><li><a href="#purojekuto_gou_chengno_zui_shi_hua"><span>4</span><span>プロジェクト構成の最適化</span></a><ul><li><a href="#gefezu_yongnoCLAUDEmdfairu_pei_zhi"><span>4.1</span><span>各フェーズ用のCLAUDE.mdファイル配置</span></a></li><li><a href="#AIni_churasenaifairuno_ming_que_hua"><span>4.2</span><span>AIに触らせないファイルの明確化</span></a></li></ul></li><li><a href="#da_gui_mopurojekutodeno_ke_tito_dui_ce"><span>5</span><span>大規模プロジェクトでの課題と対策</span></a><ul><li><a href="#furontoendobakkuendo_kai_fa_zhega_yinaru_chang_heno_tong_qi"><span>5.1</span><span>フロントエンド・バックエンド開発者が異なる場合の同期</span></a></li><li><a href="#kai_fa_shun_xuno_diao_zheng"><span>5.2</span><span>開発順序の調整</span></a></li><li><a href="#tong_shi_kai_fanotamenoapurochi"><span>5.3</span><span>同時開発のためのアプローチ</span></a></li></ul></li><li><a href="#kono_shou_fano_xiao_guo"><span>6</span><span>この手法の効果</span></a></li><li><a href="#matome"><span>7</span><span>まとめ</span></a></li></ul></div></div></div><h2><span>初めに</span></h2><p>AIと一緒に開発をするようになってから、フロントエンドとバックエンド両方を爆速で開発することができるようになって、検証が爆速で進むようになった龍ちゃんです。</p><p>AIが混乱しないようにプロジェクト自体を整備する方法についてお話しします。AIと一緒に開発を進める開発手法に関しては、以下の記事で解説をしています。</p><ul><li><a href="https://tech-lab.sios.jp/archives/49140" target="_blank" rel="noopener" title="">Claude Code革命！3フェーズ開発で効率的な開発：計画→実装→検証術</a></li><li><a href="https://tech-lab.sios.jp/archives/49148" target="_blank" rel="noopener" title="">AI協働で仕様書アレルギー克服！開発時間を1週間→2日に短縮する実践法</a></li><li><a href="https://tech-lab.sios.jp/archives/49154" target="_blank" rel="noopener" title="">Claude Code仕様書ベースでハマる6つの落とし穴！失敗回避の備忘録</a></li></ul><p>AIに触らせないファイルを作ることで過剰な生成を禁止したり、自動生成パイプラインを構築して人為的なミスを防ぐなど、プロジェクト構造レベルでの対策が重要です。</p><h2><span>実際に発生した問題事例：型定義の齟齬</span></h2><p>まず、実際に私が遭遇した問題から紹介します。</p><h3><span>環境構成</span></h3><ul><li><strong>フロントエンド</strong>: Next.js</li><li><strong>バックエンド</strong>: Nest.js</li></ul><h3><span>発生した問題</span></h3><p>フロントエンドとバックエンドで<strong>型定義の齟齬が発生</strong>していました。バックエンドで定義した型をフロントエンド側で再定義して、変更が反映されておらず<strong>参照エラーが発生</strong>する状況でした。</p><figure><img data-recalc-dims="1" decoding="async" width="800" height="500" src="https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/b060e7bc0582b2a27f7c9de8a921557f.png?resize=800%2C500&amp;ssl=1"></figure><p>この問題の根本原因は、AIが各環境で独立して型定義を生成してしまい、バックエンドの型定義変更がフロントエンドに反映されないことでした。人間の開発者なら「バックエンドで型が変わったから、フロントエンドも更新しなきゃ」と気づけますが、AIは各ファイルを独立して見てしまいます。</p><h2><span>解決策：自動生成パイプラインの構築</span></h2><p>この問題を解決するため、以下の自動生成パイプラインを構築しました：</p><figure><img data-recalc-dims="1" decoding="async" width="880" height="585" src="https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/mermaid-diagram-2025-09-15-114859.jpg?resize=880%2C585&amp;ssl=1" srcset="https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/mermaid-diagram-2025-09-15-114859.jpg?w=1920&amp;ssl=1 1920w, https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/mermaid-diagram-2025-09-15-114859.jpg?resize=1536%2C1022&amp;ssl=1 1536w, https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/mermaid-diagram-2025-09-15-114859.jpg?resize=940%2C625&amp;ssl=1 940w, https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/mermaid-diagram-2025-09-15-114859.jpg?w=1760&amp;ssl=1 1760w" sizes="(max-width: 880px) 100vw, 880px"></figure><h3><span>1. OpenAPI Spec自動生成</span></h3><p><strong>Nest.jsからOpenAPI Spec</strong>を自動生成する仕組みを導入しました。これにより、バックエンドのAPI仕様が変更されると、自動的にスペックファイルも更新されます。</p><p><a href="https://docs.nestjs.com/openapi/introduction" target="_blank" rel="noopener" title="">公式で提供されているので、コードレベルでOpenAPI Specを生成することができます。</a></p><h3><span>2. フロントエンド側の自動生成</span></h3><p><a href="https://orval.dev/" target="_blank" rel="noopener" title=""><strong>Orval</strong>を使用して、Next.jsに<strong>SWR + Axiosのリクエスト・型定義を自動生成</strong>する仕組み</a>を構築しました。OpenAPI Specから自動的にフロントエンド用のコードが生成されるため、バックエンドとフロントエンドの型定義が必ず一致します。</p><p>このシステムでは、SWRとAxiosを使ってAPIリクエストを行っており、データフェッチャーやカスタムフックが自動で提供されるため、非常に便利な仕組みになっています。</p><h3><span>3. Claude への通知</span></h3><p>最も重要なのは、<strong>Claudeに変更不可と明確に通知</strong>することです。自動生成されるファイルには、コメントやCLAUDE.mdファイルで「このファイルは自動生成されるため変更禁止」と明記し、Claudeが勝手に編集しないように徹底しました。</p><p>自動生成するためのコマンドと、どのファイルが変更不可なのかを明確に指定する必要があります。</p><h2><span>プロジェクト構成の最適化</span></h2><p>AIが迷わないよう、プロジェクト構成も工夫しています：</p><div><pre><code>/
├── CLAUDE.md                    # プロジェクト全体のガイドライン
├── docs/                        # 計画・設計フェーズ
│   ├── CLAUDE.md                # 計画フェーズ専用ルール
│   └── api/                     # OpenAPI Spec
└── application/                 # 実装フェーズ
    ├── backend/
    │   └── CLAUDE.md            # バックエンド実装ルール
    └── frontend/
        └── CLAUDE.md            # フロントエンド実装ルール</code></pre></div><h3><span>各フェーズ用のCLAUDE.mdファイル配置</span></h3><p>各ディレクトリに<strong><a href="http://CLAUDE.md">CLAUDE.md</a></strong>ファイルを配置し、そのディレクトリで作業する際の固有ルールを記載しています。例えば：</p><ul><li><code>application/frontend/CLAUDE.md</code>: 自動生成ファイルの変更禁止、使用可能なライブラリの制限など</li><li><code>application/backend/CLAUDE.md</code>: API仕様変更時の手順、データベーススキーマ変更の注意点など</li><li><code>docs/CLAUDE.md</code>: ドキュメント作成時のフォーマット、必須項目など</li></ul><h3><span>AIに触らせないファイルの明確化</span></h3><p><strong>過剰な生成を防ぐファイル管理戦略</strong>として、以下のような対策を実施しています：</p><ul><li>自動生成ファイルには必ず「DO NOT EDIT – Auto Generated」のコメントを付与</li><li>パッケージファイル（package.json等）の変更制限</li><li>設定ファイル類の変更制限</li><li>各CLAUDE.mdで変更不可ファイルのリスト明記</li></ul><p>ただし、ここまで書いていたとしても、AIは結構無視することがあります。実際に、自動生成して編集禁止にしている設定ファイルを編集しに行って動くようにしたりとか、ダイナミックな手法をやってきたりするので、いくら書いていたとしても無視をする可能性があることは念頭においた方が良いと思います。</p><h2><span>大規模プロジェクトでの課題と対策</span></h2><h3><span>フロントエンド・バックエンド開発者が異なる場合の同期</span></h3><p>大規模プロジェクトでは、フロントエンドの開発者とバックエンドの開発者が違う場合に、いかに同期を取っていくかが重要な課題となります。</p><h3><span>開発順序の調整</span></h3><p>現在のシステムだと、バックエンドの開発をしてからフロントエンドの開発をするという順番になるため、この順序をどう合わせていくかが必要です。</p><h3><span>同時開発のためのアプローチ</span></h3><p>同時に開発を進めていくためには、以下のような手法が有効です：</p><ul><li><strong>モック</strong>を使用した並行開発</li><li><strong>型定義を先に作成</strong>してOpenAPI仕様書だけを先に渡す</li><li><strong>Orvalで生成</strong>したフロントエンドコードを使ってバックエンドと協調開発</li></ul><p>このアプローチにより、フロントエンドとバックエンドの同時進行での開発が可能になります。</p><h2><span>この手法の効果</span></h2><p>自動生成パイプラインとプロジェクト整備により：</p><ul><li><strong>型定義の齟齬が完全に解消</strong></li><li>AIが余計なファイルを触ることによる意図しない変更の防止</li><li>人間が後から「なぜこの変更をしたのか分からない」状況の回避</li><li>コードレビュー時の確認ポイントの削減</li></ul><p>バックエンドを定義したら、そこからフロントエンドを並行して開発できますし、バックエンドとフロントエンドで型定義が異なるという問題がほとんどなくなりました。もちろん、バックエンドの定義自体が間違っていれば動作しませんが、フロントエンド側での型の不一致はかなり抑制できたと感じています。</p><p>これまでは自動生成の仕組みを使わずに開発していたため、コードが若干汚くなる傾向があり、フロント側で型定義の再定義が行われて連携が取れていないという問題や、型ファイルが増えていくという課題がありました。この仕組みにより、プロジェクト全体がより整理されたファイル構造になり、可読性が向上したと実感しています。</p><p>特に型定義の自動同期により、フロントエンドとバックエンドの開発を並行して進められるようになりました。</p><h2><span>まとめ</span></h2><p>正直、これは導入してみて一番良かったなと思える点ですね。ルールをあまり追加させずにAIに生成させるコードが圧倒的にきれいになりました。</p><p>ルールをガッチガチにしてコードをきれいにするというのも今後の検証として取り込んでいきます。</p><!-- Anyway Feedback Container //--><div>ご覧いただきありがとうございます！

<span>この投稿はお役に立ちましたか？</span><br><br><a href="#afb-post-49157">役に立った</a><a href="#afb-post-49157">役に立たなかった</a><br><br><span>0人がこの投稿は役に立ったと言っています。</span><input type="hidden" name="post_type" value="post"><input type="hidden" name="object_id" value="49157"></div><!-- //Anyway Feedback Container -->