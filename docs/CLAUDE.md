# 計画フェーズのルール

## 目的
AIに人間の意図を適切に伝えて効率的な開発を行うための仕様書・計画書を作成する

## このディレクトリの役割

`docs/` ディレクトリは**計画フェーズ**専用です。実装コードは一切書きません。

### ディレクトリ構成
```
docs/
├── CLAUDE.md                    # このファイル（計画フェーズルール）
├── spec/                        # 確定した仕様の保管場所
│   ├── frontend/                # フロントエンド機能の確定仕様
│   │   └── [feature-name].md
│   ├── marp/                    # Marpスライドの確定仕様
│   │   └── [slide-name].md
│   ├── tools/                   # ツールの確定仕様
│   │   └── [tool-name].md
│   └── infra/                   # インフラの確定仕様
│       └── [infrastructure-name].md
├── features/                    # 新機能の計画書（ディレクトリ単位）
│   └── [feature-name]/          # 機能ごとのディレクトリ
│       ├── spec.md              # 仕様書（必須）
│       ├── plan.md              # 実装計画書（必須）
│       └── assets/              # 仕様書用の図表・画像（任意）
├── bugs/                        # バグ調査・修正計画（ディレクトリ単位）
│   └── [bug-name]/              # バグごとのディレクトリ
│       ├── spec.md              # バグ調査・修正仕様書
│       └── plan.md              # 修正計画書
├── research/                    # 検証結果・知見
│   └── [topic]-review.md        # 実装レビュー結果
└── templates/                   # 仕様書テンプレート
    ├── README.md                # テンプレート使用方法
    ├── spec-template-*.md       # 仕様書テンプレート
    └── CLAUDE-*.md              # 各フェーズ用CLAUDE.md
```

## 計画フェーズで行うこと

### 設計・仕様書作成
- ✅ 型定義の設計
- ✅ データベース構造の設計
- ✅ API 仕様の定義
- ✅ アーキテクチャ設計
- ✅ 機能要件の明確化
- ✅ 非機能要件の定義
- ✅ **情報設計**（何を表示するか、優先度は何か）

### 計画書作成
- ✅ 実装スコープの明確化
- ✅ タスクの分割
- ✅ リスクの洗い出しと対策
- ✅ 検証計画の策定
- ✅ 成功基準の定義

## 計画フェーズで禁止すること

- ❌ **実装コードの記述禁止**
- ❌ **具体的なロジックの記述禁止**
- ❌ **デザインの詳細指定禁止**（色、フォントサイズ、レイアウトなど）
- ❌ **具体的な関数実装禁止**
- ❌ **ライブラリの選定禁止**（技術スタックが決まっている場合を除く）

## 計画フェーズで重視すること（AIデザイン駆動）

### 情報設計
- ✅ **何を表示するか**（情報項目の定義）
- ✅ **優先度は何か**（最重要・重要・補足）
- ✅ **どう操作するか**（インタラクションの定義）

### 機能要件
- ✅ **入力は何か**（データ形式、検証ルール）
- ✅ **出力は何か**（期待される結果）
- ✅ **エラーケースは何か**（エッジケースの洗い出し）

### データ構造
- ✅ **型定義**（TypeScript interfaceレベル）
- ✅ **データの流れ**（入力→処理→出力）
- ✅ **状態管理**（どの状態を管理するか）

## ファイル命名規則

### featuresディレクトリ
機能ごとにディレクトリを作成し、その中に`spec.md`と`plan.md`を配置します。

**命名パターン**:
```
features/
├── frontend-[feature-name]/     # フロントエンド機能
│   ├── spec.md
│   ├── plan.md
│   └── assets/                  # 図表・画像（任意）
├── marp-[slide-name]/           # Marpスライド
│   ├── spec.md
│   └── plan.md
└── tool-[tool-name]/            # ツール開発
    ├── spec.md
    └── plan.md
```

**例**:
- `features/frontend-astro-react-setup/` - フロントエンド環境構築
- `features/frontend-blog-index/` - ブログ一覧ページ
- `features/marp-claude-intro/` - Claudeセミナースライド
- `features/tool-index-generator/` - HTMLインデックス生成ツール

### bugsディレクトリ
バグごとにディレクトリを作成します。

**命名パターン**:
```
bugs/
└── [bug-name]/
    ├── spec.md     # バグ調査と修正方針
    └── plan.md     # 修正計画
```

**例**:
- `bugs/login-error-fix/`
- `bugs/build-failure-investigation/`

### researchディレクトリ
検証結果は単一ファイルで管理します。

**命名パターン**:
```
research/
└── [topic]-review.md
```

**例**:
- `research/frontend-astro-setup-review.md`
- `research/authentication-implementation-review.md`

### specディレクトリ
実装・検証が完了し、運用に乗った機能の**確定仕様**を保管します。

**役割**:
- `features/` で計画した仕様が実装・検証を経て確定したものを保存
- 運用中の機能の安定版仕様として管理
- 他のドキュメントや新機能開発時の参照元として使用

**命名パターン**:
```
spec/
├── frontend/
│   └── [feature-name].md        # 例: blog-index.md, article-detail.md
├── marp/
│   └── [slide-name].md          # 例: claude-intro.md, writing-workflow.md
├── tools/
│   └── [tool-name].md           # 例: scraper.md, index-generator.md
└── infra/
    └── [infrastructure-name].md # 例: github-pages-deployment.md
```

**例**:
- `spec/frontend/blog-index.md` - ブログ一覧ページの確定仕様
- `spec/marp/claude-intro.md` - Claudeセミナースライドの確定仕様
- `spec/tools/scraper.md` - スクレイパーツールの確定仕様
- `spec/infra/github-pages-deployment.md` - GitHub Pages デプロイメントの確定仕様

**管理ルール**:
1. **昇格タイミング**: 実装・検証完了後、運用開始時に `features/` から移動またはコピー
2. **バージョン管理**: 大きな変更がある場合は、ファイル名に日付を付与（例: `blog-index-2025-01.md`）
3. **変更履歴**: ドキュメント内に変更履歴セクションを設け、更新日時と変更内容を記録
4. **参照の安定性**: 確定仕様は頻繁に変更しない（変更時は新バージョンとして保存）

**ワークフロー**:
```
features/frontend-blog-index/spec.md
    ↓ (実装)
application/frontend/src/pages/blog/
    ↓ (検証)
docs/research/blog-index-review.md
    ↓ (確定・昇格)
spec/frontend/blog-index.md
```

**活用方法**:
新機能開発時や既存機能の改修時に、関連する確定仕様を参照することで：
- ✅ **既存の設計パターンを踏襲**: 一貫性のある実装が可能
- ✅ **過去の学びを活用**: 試行錯誤の結果や重要な学びを参照
- ✅ **重複作業の回避**: 似た機能の実装方法をすぐに確認
- ✅ **技術的整合性の確保**: 既存のアーキテクチャとの整合性を保つ

**参照例**:
```bash
# 新しいフロントエンド機能を開発する前に
ls docs/spec/frontend/          # 既存の確定仕様を確認

# インフラ変更時に
cat docs/spec/infra/github-pages-deployment.md  # デプロイ構成を確認
```

## 仕様書の構成

### spec.md（仕様書）
機能の詳細な仕様を記述します。

**必須セクション**:
1. **概要**: 機能の目的と概要
2. **背景・課題**: なぜこの機能が必要か
3. **情報設計**（フロントエンド）または **機能要件**（バックエンド/ツール）
4. **データ仕様**: 入力・出力・型定義
5. **非機能要件**: パフォーマンス、セキュリティなど
6. **デザイン指針**（AIに委ねる）
7. **技術的制約**
8. **テスト観点**

### plan.md（計画書）
実装の進め方を記述します。

**必須セクション**:
1. **プロジェクト概要**: 目的とスコープ
2. **開発アプローチ**: 3フェーズ開発の適用
3. **技術仕様サマリー**: 使用技術の一覧
4. **作成するファイルの詳細**: ファイルごとの詳細仕様
5. **検証計画**: テスト項目と合格基準
6. **リスクと対策**: 想定されるリスク
7. **成功基準**: 完了判定基準
8. **タイムライン**: 想定スケジュール

## テンプレートの使用方法

### 新機能開発の流れ

**ステップ1: ディレクトリ作成**
```bash
mkdir -p docs/features/[feature-name]
```

**ステップ2: テンプレートコピー**
```bash
# フロントエンド機能の場合
cp docs/templates/spec-template-frontend.md docs/features/frontend-[name]/spec.md

# Marpスライドの場合
cp docs/templates/spec-template-marp.md docs/features/marp-[name]/spec.md

# ツール開発の場合
cp docs/templates/spec-template-tool.md docs/features/tool-[name]/spec.md
```

**ステップ3: 関連する確定仕様の確認**
新機能が既存機能と関連する場合、確定仕様を参照：
```bash
# 関連する確定仕様を確認
ls docs/spec/[category]/

# 例：フロントエンド機能の場合
ls docs/spec/frontend/

# 例：インフラ関連の場合
ls docs/spec/infra/
```

**ステップ4: 仕様書作成**
Claude Codeに依頼（関連する確定仕様がある場合は参照）：
```
以下のテンプレートを元に、[機能名]の仕様書を作成してください：
@docs/features/[feature-name]/spec.md

# 関連する確定仕様がある場合は参照
参考：
@docs/spec/[category]/[related-spec].md

要件：
- [要件1]
- [要件2]
- [要件3]
```

**ステップ5: 計画書作成**
仕様書を元に計画書を作成：
```
@docs/features/[feature-name]/spec.md を元に、
実装計画書（plan.md）を作成してください。

以下を含めてください：
- 実装スコープ
- タスク分割
- リスクと対策
- 検証計画
- 成功基準
```

### バグ修正の流れ

**ステップ1: ディレクトリ作成**
```bash
mkdir -p docs/bugs/[bug-name]
```

**ステップ2: テンプレートコピー**
```bash
cp docs/templates/spec-template-bug.md docs/bugs/[bug-name]/spec.md
```

**ステップ3-4**: 新機能開発と同様

## レビューポイント

### 仕様書のレビュー
- ✅ 要件の抜け漏れはないか
- ✅ 設計の整合性は取れているか
- ✅ スケーラビリティは考慮されているか
- ✅ セキュリティ要件は満たしているか
- ✅ **情報設計が明確か**（フロントエンドの場合）
- ❌ デザインの詳細を指定していないか
- ❌ 実装コードを書いていないか

### 計画書のレビュー
- ✅ 実装スコープが明確か
- ✅ タスク分割が適切か
- ✅ リスクが洗い出されているか
- ✅ 検証計画が具体的か
- ✅ 成功基準が測定可能か
- ✅ タイムラインが現実的か

## 実装フェーズへの移行

計画フェーズが完了したら、実装フェーズに移行します。

**移行コマンド例**:
```
以下の仕様書を読み込んで実装してください：
@docs/features/[feature-name]/spec.md

# 関連する確定仕様がある場合は参照
参考にする確定仕様：
@docs/spec/[category]/[related-spec].md

実装方針：
- [方針1]
- [方針2]
- デザインの詳細はあなたの判断で最適なものを選択
```

**注意事項**:
- 実装フェーズでは該当ワークスペースの`CLAUDE.md`を読み込む
  - `application/marp/CLAUDE.md`
  - `application/frontend/CLAUDE.md`
  - `application/tools/CLAUDE.md`

## AIとの協働のコツ

### 仕様書作成時
- 要件を箇条書きで整理してから依頼
- 曖昧な部分は質問してもらう
- 繰り返し改善することを前提とする

### レビュー時
- AIに「この仕様書で不明瞭な点はありますか？」と質問
- 実装時に困りそうな点を洗い出す
- デザインの詳細が書かれていないか確認

### よくある問題と対処法

**問題: AIが実装コードを書き始める**
- 対処: 「コードは一切書かないでください」と明記
- CLAUDE.mdの「禁止事項」を強調

**問題: 仕様書が曖昧で実装時に混乱する**
- 対処: 実装前に「この仕様書で不明瞭な点はありますか？」と質問
- 具体例を追加する

**問題: デザインの詳細を書いてしまう**
- 対処: 「情報の優先度」のみを書き、「色、フォント」は書かない
- AIデザイン駆動の原則を守る

## ベストプラクティス

### 1. 確定仕様を積極的に活用する
- 新機能開発前に `docs/spec/` を確認し、関連する確定仕様を参照
- 既存の設計パターンや技術スタックを踏襲することで、一貫性のある実装を実現
- 過去の試行錯誤や重要な学びを活かし、同じ問題を繰り返さない
- 関連する確定仕様がある場合は、仕様書作成時と実装時に明示的に参照

### 2. 小さく始める
- 最初から完璧を目指さない
- 小規模な機能で試してみる
- 検証フェーズで学びを得て改善

### 3. 情報設計に注力（フロントエンド）
- 「何を」「どの順で」表示するかを明確に
- 「どう見せるか」はAIに任せる
- 情報の優先度を3段階（最重要・重要・補足）で定義

### 4. 入出力を明確に（バックエンド/ツール）
- 入力の形式を具体例で示す
- 出力の期待値を明確にする
- エラーケースを網羅的にリストアップ

### 5. 段階的に改善
- 仕様書は1回で完璧にならない
- 検証フェーズの学びを次回に活かす
- テンプレート自体も改善していく

## 参考資料

### プロジェクト内ドキュメント
- 仕様書ベース開発ガイド: `docs/spec-based-development-guide.md`
- テンプレート使用方法: `docs/templates/README.md`
- プロジェクト全体ガイド: `CLAUDE.md`

### 各ワークスペースの実装ルール
- Marp: `application/marp/CLAUDE.md`
- Frontend: `application/frontend/CLAUDE.md`
- Tools: `application/tools/CLAUDE.md`

---

## まとめ

### 計画フェーズの成功の鍵

1. **コードを書かない**: 計画フェーズでは仕様と計画のみ
2. **情報設計に注力**: デザイン詳細はAIに委ねる
3. **具体的に書く**: 曖昧さを排除し、具体例を示す
4. **レビューを徹底**: 実装前に仕様書の抜け漏れを確認
5. **段階的改善**: 完璧を目指さず、繰り返し改善

### 次のステップ

計画フェーズ完了後：
1. 仕様書と計画書をレビュー
2. 不明点があればAIに質問
3. 問題なければ実装フェーズへ移行
4. 実装後に検証フェーズで学びを得る

**重要**: この計画フェーズの品質が実装の成功を左右します。焦らず、丁寧に仕様を固めることが、結果的に開発時間の短縮につながります。
