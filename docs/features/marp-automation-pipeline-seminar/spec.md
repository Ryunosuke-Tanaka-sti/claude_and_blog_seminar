# Marpスライド仕様書：AI開発を効率化する環境整備術

## 概要
AI協働開発における「計画ドキュメント + 型定義・関数の自動生成（パーツ化）」の実践手法を解説する技術セミナー資料。仕様書ベースでの開発を前提に、Next.js×Nest.jsでの自動生成パイプラインを例に、AIが効率的に開発できる環境整備の具体的な手法と実測データを共有する。

## 前提：仕様書ベースでの開発
このセミナーは、**計画ドキュメント（仕様書）をもとに実装する開発スタイル**を前提としています。

### なぜ仕様書が必要なのか
- **開発時間の短縮**: 1週間 → 2日（実測データ）
- **手戻りの削減**: 平均3-4回 → 平均1回
- **意思決定の明文化**: AIに技術選定を委ねる危険性を回避
- **品質保証**: 計画の品質が成果物の品質を決定

### 仕様書ベースのメリット（AI協働開発）
- AIに「何を作るか」を明確に伝えられる
- 検討不足や考慮不足を事前に発見できる
- AIが作った仕様書をレビューする経験が得られる
- 開発前に機能の整理ができる

参考記事:
- [AI協働で仕様書アレルギー克服！開発時間を1週間→2日に短縮する実践法](https://tech-lab.sios.jp/archives/49148)
- [AI協働開発の落とし穴回避！3ヶ月で実証した計画ドキュメントの価値](https://tech-lab.sios.jp/archives/49594)
- [【2025年版】検証→記事化で知見を資産化！Claude Code×RAGもどきでAI技術ブログ執筆を効率化](https://tech-lab.sios.jp/archives/50103)

## 目的・ゴール
- **AI開発を効率化する環境整備**の重要性を伝える（仕様書ベース開発を前提）
- 型定義・関数の自動生成（パーツ化）でAIのハチャメチャなコードを防ぐ
- 再定義のリスクを排除し、効率的な開発を実現する手法を共有
- Single Source of Truth（DTO → OpenAPI → Frontend）で人間もAIも迷わない設計を実現

## ターゲットオーディエンス
- AI協働開発でコード品質を保ちたい開発者
- AIがハチャメチャなコードを生成して困っている人
- フロント・バックの型定義の手動管理に課題を感じているチーム
- 自動生成パイプラインでAI開発を効率化したいエンジニア

## 伝えたいメッセージ（最重要）

### 核となるメッセージ
1. **AI開発の環境整備が成功の鍵**: 型定義・関数のパーツ化でAIのハチャメチャなコードを防ぐ
2. **Single Source of Truth**: DTOを唯一の型定義源とすることで、人間もAIも迷わない
3. **パーツ提供の思想**: すべてを自動生成せず、必要な型・関数だけを提供（shadcn/uiと同じ）
4. **実測データの説得力**: 再定義のリスクを排除し、効率的な開発を実現（47ファイル移行で70-79%効率化）

### 各メッセージの重要度
- 🔴 最重要:
  - AI開発を効率化する環境整備の重要性
  - パーツ提供の考え方（型・関数の自動生成）
  - Single Source of Truthで人間もAIも迷わない設計
  - 再定義のリスク排除による効率化
- 🟡 重要:
  - エラー型設計の必要性（型安全なエラーハンドリング）
  - Orval最適化の実測データ（バンドル20-30%削減、移行70-79%効率化）
  - AIがハチャメチャなコードを出さなくなった実体験
- 🟢 補足:
  - 大規模プロジェクトでの並行開発
  - axiosInstance vs axiosClientの区別
  - 移行中に発見したバグ事例

## スライド構成

### 全体構成（推奨枚数: 40-45枚）

```
1. タイトルスライド (1枚)
   - タイトル: AI開発を効率化する環境整備術
   - サブタイトル: 型定義・関数のパーツ化でハチャメチャなコードを防ぐ

2. 本日のゴール (1枚)
   - AI開発の環境整備の重要性
   - パーツ提供の思想（型・関数の自動生成）
   - 実測データ（開発時間1週間→2日、効率化70-79%）

3. 前提: 仕様書ベースでの開発 (1枚)
   - このセミナーは計画ドキュメント（仕様書）をもとに実装する開発スタイルを前提
   - メリット: 開発時間短縮、手戻り削減、意思決定の明文化
   - 参考記事2つの紹介

4. Specベースのフレームワーク（一般論）(1枚)
   - TDD（Test-Driven Development）: テストファーストで設計
   - BDD（Behavior-Driven Development）: ビジネス要件を自然言語で記述
   - Design by Contract: 契約による設計
   - SDD（Specification-Driven Development）: 仕様ファーストで開発
   - AI協働開発でのSpec活用: 計画ドキュメントが「Spec」の役割

5. 3フェーズ開発手法（計画→実装→検証）(3枚)
   - なぜフェーズを分けるのか
   - 計画フェーズ: 仕様書をAIに作成させ、人間がレビュー
   - 実装フェーズ: 仕様書を読み込ませ、AIが実装
   - 検証フェーズ: 計画と実装の差分を分析し、学びを蓄積
   - **拡張版**: 4フェーズワークフロー（計画→実装→研究→執筆）

6. セミナー構成 (1枚)

7. Part 1: AI開発の課題と環境整備の必要性（10分、7枚）
   - AIがハチャメチャなコードを出す3つの原因
   - 具体例: 型定義の再定義による不整合
   - AI開発の本質的な課題
   - 解決策: 環境整備による制約の設計
   - Single Source of Truth（人間もAIも迷わない設計）
   - なぜパーツ化が必要なのか

7.5. モノレポ構成の全体像（5分、3-4枚）
   - プロジェクト全体構成（4つのアプリケーション）
   - なぜモノレポなのか（AI協業との相性）
   - docs/ と application/ の分離
   - CLAUDE.md階層構造の概要
   - モノレポがパイプライン構築の基盤となる理由

8. Part 2: 自動生成パイプラインの構築（15分、13枚）
   - パイプラインの全体像（図解中心）
   - ステップ1: DTOを唯一の型定義源とする
   - OpenAPI Spec自動生成の流れ
   - 重要: エラー型設計の必要性（型安全なエラーハンドリング）
   - ステップ2: 型・関数のパーツ化（Orvalの役割）
   - 生成される成果物（型定義 + API関数）
   - ステップ3: AIへの通知と制御（DO NOT EDIT、CLAUDE.md）
   - プロジェクト構成の最適化（図解）
   - AIが触らないファイルの明確化
   - 大規模プロジェクトでの運用課題

9. Part 3: パーツ化の最適化実践（10分、10枚）
   - すべてを自動生成する罠
   - パーツ化の失敗例（Before: 全自動生成）
   - パーツ化の成功例（After: 必要なものだけ生成）
   - 最適化された設定（図解・比較表中心）
   - パーツ提供の考え方（shadcn/uiとの類似性）
   - 適材適所のアプローチ（図解）
   - 移行結果の数値効果（表）
   - AI協働による効率化の実測データ
   - AIがハチャメチャなコードを出さなくなった実体験

10. まとめ・実践への提案（5分、5枚）
   - 重要ポイントの整理
   - 段階的導入ステップ
   - よくある質問（厳選3問）
   - 今日から試せること
   - 参考記事・リソース

11. Appendix（時間外、3-5枚）
   - 実装チェックリスト
   - トラブルシューティング
   - よくある質問（追加Q&A）
```

### セクション別詳細

#### セクション0: Specベースのフレームワーク（一般論）(1枚)
**目的**: 仕様書ベース開発の歴史的背景と、AI協働開発での活用を理解してもらう

**スライド構成**:
1. Specベースのフレームワーク（一般論）
   - **TDD（Test-Driven Development）**: テストファーストで設計の安全網
   - **BDD（Behavior-Driven Development）**: ビジネス要件を自然言語（Given-When-Then）で記述
   - **Design by Contract**: 契約（事前条件・事後条件・不変条件）による設計
   - **SDD（Specification-Driven Development）**: 仕様ファーストで「何を」「なぜ」を明確化
   - **AI協働開発でのSpec活用**: 計画ドキュメントが「Spec」の役割を果たす
   - 2025年のトレンド: これらの手法を組み合わせて使用（BDD + TDD、DbC + TDD）
   - **図解またはテキスト**: 各手法の特徴を簡潔に

#### セクション0-2: 3フェーズ開発手法（計画→実装→検証）(3枚)
**目的**: AI協働開発における3フェーズ（基本）と4フェーズ（拡張版）の全体像を理解してもらう

**スライド構成**:
1. なぜフェーズを分けるのか
   - 従来のペアコーディング（Vibe Coding）の限界
   - 300文字で意図を伝えるのは文豪でも困難
   - AIが自由に解釈しすぎて、意図したものが作られない
   - **図解**: ペアコーディングの課題

2. 3フェーズ開発手法の全体像
   - **計画フェーズ（Planning）**: 仕様書をAIに作成させ、人間がレビュー（コードは一切書かせない）
   - **実装フェーズ（Implementation）**: 仕様書を読み込ませ、AIが実装（人間は監視役）
   - **検証フェーズ（Research）**: 計画と実装の差分を分析し、学びを蓄積
   - **図解**: 3フェーズのフロー図
   - 実測データ: 開発時間1週間 → 2日、手戻り平均3-4回 → 平均1回

3. 拡張版: 4フェーズワークフロー
   - **1. 計画フェーズ（Planning）**: `docs/features/機能名/` に仕様書を作成
   - **2. 実装フェーズ（Implementation）**: `application/` 配下で実装
   - **3. 研究フェーズ（Research）**: `docs/research/` に知見をドキュメント化（実装と並行可能）
   - **4. 執筆フェーズ（Writing）**: `docs/article/機能名/` でブログ記事を執筆
   - **図解**: 4フェーズのフロー図（計画→実装⇄研究→執筆）
   - **テキストベース**: RAGもどきでトークン削減50-60%、記事執筆時間50%削減

#### セクション1: Part 1 - AI開発の課題と環境整備の必要性（10分）
**目的**: AIがハチャメチャなコードを出す原因と、環境整備による解決策を理解してもらう

**スライド構成**:
1. セクションタイトル
   - タイトル: 「Part 1: AI開発の課題と環境整備の必要性」
   - サブタイトル: 「なぜAIはハチャメチャなコードを出すのか」

2. AIがハチャメチャなコードを出す3つの原因
   - 原因1: 型定義を再定義してしまう（フロント・バックで独立に生成）
   - 原因2: エラー型が不明確（`any`型で実行時エラー）
   - 原因3: 過剰な自動生成（不要なコードが大量に生成される）
   - **図解**: 問題の全体像（テキストベース）

3. 具体例: 型定義の再定義による不整合
   - **図解**: バックエンド（DTO） vs フロントエンド（再定義）の比較
   - 問題: 必須/オプショナルの不一致
   - 結果: コンパイルは通るが、ランタイムでエラー
   - **コードは使わず、図解とテキストで説明**

4. AI開発の本質的な課題
   - AIは各ファイルを独立して見てしまう
   - 人間なら気づく「バックエンドが変わったからフロントも更新」ができない
   - 型定義の再定義によるリスク

5. 解決策: 環境整備による制約の設計
   - AIに「正しいパーツ」を提供する
   - 再定義を防ぐ仕組みを作る
   - 人間もAIも迷わない設計

6. Single Source of Truth（人間もAIも迷わない設計）
   - 設計思想: DTOを唯一の型定義源とする
   - 自動生成による同期
   - AI協働開発との相性

7. なぜパーツ化が必要なのか
   - 人間とAIの役割分担の再定義
   - AIには「型・関数のパーツ」を提供し、組み立ては任せる
   - shadcn/uiと同じ思想

#### セクション1.5: モノレポ構成の全体像（5分）
**目的**: パイプライン構築の前提となるモノレポ構成を理解してもらう

**スライド構成**:
1. セクションタイトル
   - タイトル: 「モノレポ構成の全体像」
   - サブタイトル: 「AI協業開発を支える基盤」

2. プロジェクト全体構成（4つのアプリケーション）
   - **表**: Frontend (Next.js 15) / Backend (NestJS 11) / Functions (Azure Functions) / MCP Functions
   - デプロイ先: Azure Static Web Apps / Azure Web Apps / Azure Functions
   - **図解**: 4つのアプリケーションの関係図
   - **テキスト**: 各アプリケーションの役割

3. なぜモノレポなのか（AI協業との相性）
   - **3つのメリット**:
     - ① AIに1つのリポジトリで全体像を提供できる
     - ② ディレクトリ構造の一貫性（すべてのアプリに同じルール）
     - ③ コード共有が容易（共通ライブラリ、型定義、ユーティリティ）
   - **図解**: 別リポジトリ vs モノレポの比較
   - **テキストベース**: AIがコンテキストを理解しやすい

4. docs/ と application/ の分離
   - **図解**: ディレクトリ構造
     - `/docs/` - 計画・設計フェーズ（実装コードなし）
     - `/application/` - 実装フェーズ（実装コード）
     - `/infrastructure/` - IaCテンプレート
   - **目的**: AIに「計画」と「実装」を明確に区別させる
   - **効果**: 実装前に設計を固めることで手戻りを減らす

5. CLAUDE.md階層構造の概要
   - **9つのCLAUDE.mdファイル**: ルート + サブディレクトリ
   - **図解**: CLAUDE.md階層図（ルート → docs → application）
   - **役割**:
     - ルートCLAUDE.md - プロジェクト全体像
     - サブディレクトリCLAUDE.md - 各領域の詳細ルール
   - **効果**: AIが必要な粒度でコンテキストを取得
   - **詳細は別記事へ**: モノレポ×AI協業環境構築術の記事を紹介

6. モノレポがパイプライン構築の基盤となる理由
   - **Single Source of Truth**: Backend DTOsを唯一の真実とする
   - **型定義の一元管理**: モノレポ内でBackend → Frontendの型定義が自動同期
   - **AIへの明確な指示**: `/application/backend/`でDTO定義 → 自動生成で`/application/frontend/`に型提供
   - **次のセクションへの橋渡し**: この基盤の上にパイプラインを構築する

#### セクション2: Part 2 - 自動生成パイプラインの構築（15分）
**目的**: DTO → OpenAPI → 型・関数パーツ化の具体的な実装手法を伝える（図解・テキスト中心）

**スライド構成**:
1. セクションタイトル
   - タイトル: 「Part 2: 自動生成パイプラインの構築」
   - サブタイトル: 「DTO → OpenAPI → 型・関数のパーツ化」

2. パイプラインの全体像
   - **図解**: Nest.js DTO → OpenAPI Spec → Orval → Next.js（型定義 + API関数）
   - 人間もAIも触らないファイルを作成
   - **コードは使わず、フロー図で説明**

3. ステップ1: DTOを唯一の型定義源とする
   - DTOクラスがすべての型定義のマスター
   - デコレーターから制約情報も自動抽出
   - **図解またはテキスト**: DTOの役割
   - **コードサンプルは最小限（5-7行程度）**

4. OpenAPI Spec自動生成の流れ
   - **図解**: DTO → OpenAPI Specの変換
   - 生成される仕様の品質（完全性・詳細度・ドキュメント）
   - **コードは使わず、概念図とテキストで説明**

5. 重要: エラー型設計の必要性
   - 問題: エラー型が自動生成されない → `any`型になる
   - 解決: RFC 7807準拠の統一エラー型
   - 型安全なエラーハンドリングの実現

6. エラー型の基本構造
   - **テキストベース**: type、title、status、detail、timestamp、traceId
   - 各エンドポイントでエラー型を定義
   - 利点: IDEの補完が効く、実行時エラーを防げる
   - **コードは使わず、構造図とテキストで説明**

7. ステップ2: 型・関数のパーツ化（Orvalの役割）
   - Orvalとは: OpenAPI仕様からTypeScriptコード自動生成
   - **図解**: 何を生成するか（型定義 + API関数）
   - **コードは使わず、概念とテキストで説明**

8. 生成される成果物
   - **図解または箇条書き**: 型定義ファイル vs API呼び出し関数
   - DTOと1対1対応
   - 型安全なAPI関数
   - **コードサンプルは削除、概念図で説明**

9. ステップ3: AIへの通知と制御
   - DO NOT EDITコメントの挿入
   - CLAUDE.mdでの明文化
   - 注意: AIは時々無視する（約10-20%の確率）

10. プロジェクト構成の最適化
    - **図解**: ディレクトリ構造（CLAUDE.mdの配置）
    - 人間もAIも触らないファイルを明確化

11. AIが触らないファイルの明確化
    - 自動生成ファイル（`lib/api/generated.ts`, `types/generated/`）
    - 変更必要時は `backend/` の定義を修正 → `npm run generate:api` で再生成
    - **コードは使わず、ルールとフローで説明**

12. 各CLAUDE.mdの役割
    - プロジェクト全体、バックエンド、フロントエンド
    - 各フェーズでの責任範囲明確化

13. 大規模プロジェクトでの運用課題
    - 課題: フロント・バック担当者が異なる場合
    - 解決策: モックサーバー、型定義先行アプローチ、段階的統合

#### セクション3: Part 3 - パーツ化の最適化実践（10分）
**目的**: すべてを自動生成する罠を回避し、必要なパーツだけを提供する実践手法を共有（図解・テキスト中心）

**スライド構成**:
1. セクションタイトル
   - タイトル: 「Part 3: パーツ化の最適化実践」
   - サブタイトル: 「すべてを自動生成する罠と解決策」

2. すべてを自動生成する罠
   - 初期設定: 全APIエンドポイントにSWRフック自動生成
   - 発生した問題: バンドル肥大化、不要なオーバーヘッド
   - **図解**: 問題の全体像
   - **コードは使わず、概念図とテキストで説明**

3. パーツ化の失敗例（Before: 全自動生成）
   - 全エンドポイント分のSWRフックが生成される
   - バンドルサイズ肥大化
   - 不要なコードが大量に含まれる
   - **表または図解**: Before の問題点

4. パーツ化の成功例（After: 必要なものだけ生成）
   - 型定義 + Axios関数のみ生成
   - SWRは必要な箇所のみ手動実装
   - バンドルサイズ削減
   - **表または図解**: After の改善点

5. 最適化された設定
   - **図解または比較表**: Before vs After
   - mode: "single" で直接エクスポート
   - client: "axios-functions" でパーツのみ生成
   - **設定の詳細はテキストで、コードは最小限**

6. パーツ提供の考え方（shadcn/uiとの類似性）
   - ハイライト: すべてを自動生成するのではなく、組み立てやすいパーツを提供
   - shadcn/uiの成功と同じアプローチ
   - コンポーネントをコピペして、必要に応じてカスタマイズ
   - AI開発効率化の鍵

7. 適材適所のアプローチ
   - **図解**: Read（GET）→ カスタムSWRフック、CUD（POST/PUT/DELETE）→ 直接Axios
   - データ取得: SWRのキャッシュ・再検証・データ共有
   - Mutation: シンプルにAxiosで十分
   - **コードは使わず、図解とテキストで説明**

8. 移行結果の数値効果
   - **表**: 対象範囲、実測データ
   - 自動生成フック数: 41個 → 0個
   - バンドルサイズ: 100% → 70-80%（20-30%削減）
   - コード行数: ~2030行 → ~800行（約60%削減）

9. AI協働による効率化の実測データ
   - 推定14-20時間 → 実績4.2時間（70-79%効率化）
   - なぜこれほど効率化できたのか: Axiosの関数がパーツとして提供されていた
   - AIに実装を任せる際もスムーズに進行
   - 型定義が自動生成されているため、型エラーで即座に問題検出

10. AIがハチャメチャなコードを出さなくなった実体験
    - 再定義のリスクを排除
    - 型定義の齟齬がなくなった
    - フロントエンドで型定義ファイルが増殖しなくなった
    - すっきりとしたコードで実装できるようになった

#### セクション4: まとめ・実践への提案（5分）
**目的**: 重要ポイントを整理し、今日から実践できるステップを提示

**スライド構成**:
1. セクションタイトル
   - タイトル: 「まとめ・実践への提案」
   - サブタイトル: 「今日から始める自動化パイプライン」

2. 重要ポイントの整理
   - 左右2カラムで6つのポイント

3. 段階的導入ステップ
   - Step 1: 基本パイプラインの構築（1-2日）
   - Step 2: 既存コードの移行（規模による）

4. よくある質問（厳選3-5問）
   - Q2: エラー型を定義しないとどうなりますか？
   - Q3: axiosClient と axiosInstance の違いがわかりません
   - Q5: バンドルサイズは本当に削減されますか？

5. 今日から試せること
   - ハイライト: まず「DTOクラス + エラー型定義」から始めましょう
   - 小さく始める、効果を実感する

6. 参考記事・リソース
   - 自動化パイプライン関連記事
   - 3フェーズ開発手法（基盤）
   - 公式ドキュメント

## 図解・ビジュアル要素

### 必要な図解リスト

| # | スライド | 図解の種類 | 目的 | 説明 |
|---|---------|----------|------|------|
| 1 | Spec一般論 | テキスト・箇条書き | フレームワーク比較 | TDD、BDD、DbC、SDDの特徴を簡潔に |
| 2 | 3フェーズ-1 | 問題図 | ペアコーディングの課題 | Vibe Codingの限界 |
| 3 | 3フェーズ-2 | フロー図 | 3フェーズ全体像 | 計画→実装→検証のフロー |
| 3.5 | 3フェーズ-3 | フロー図 | 4フェーズ拡張版 | 計画→実装⇄研究→執筆のフロー |
| 4 | Part 1-2 | 図解 | 問題の全体像 | AIがハチャメチャなコードを出す3つの原因 |
| 5 | Part 1-3 | 比較図 | 型定義の不整合 | バックエンド（DTO） vs フロントエンド（再定義） |
| 5.5 | モノレポ-2 | 表 | 4つのアプリケーション | Frontend/Backend/Functions/MCP Functionsの技術スタックとデプロイ先 |
| 5.6 | モノレポ-3 | 比較図 | 別リポジトリ vs モノレポ | AIのコンテキスト理解の違い |
| 5.7 | モノレポ-4 | ディレクトリ構造 | docs/とapplication/の分離 | 計画と実装の明確な区別 |
| 5.8 | モノレポ-5 | 階層図 | CLAUDE.md階層構造 | ルート → サブディレクトリのコンテキスト継承 |
| 6 | Part 2-2 | フロー図 | パイプラインの流れ | DTO → OpenAPI → 型・関数のパーツ化 |
| 7 | Part 2-4 | 概念図 | OpenAPI変換 | DTO → OpenAPI Specの変換プロセス |
| 8 | Part 2-6 | 構造図 | エラー型 | RFC 7807準拠のエラーレスポンス構造 |
| 9 | Part 2-8 | 概念図 | 生成物 | 型定義ファイル vs API関数の役割 |
| 10 | Part 2-10 | ディレクトリ構造 | プロジェクト構成 | CLAUDE.mdの配置とAIが触らないファイル |
| 11 | Part 3-2 | 問題図 | 全自動生成の罠 | 不要なコード生成の問題 |
| 12 | Part 3-5 | 比較表 | 設定の変更 | Before（全自動） vs After（パーツのみ） |
| 13 | Part 3-7 | フロー図 | 適材適所 | Read → SWR、CUD → Axiosの使い分け |
| 14 | Part 3-8 | 表 | 数値効果 | バンドルサイズ、コード行数、移行工数 |

### 図解のガイドライン
- **コードブロックは極力使わない**（最小限の場合のみ5-7行程度）
- 図解・テキスト・箇条書きで説明する
- 表は3-5行、3-4列に抑える
- 2カラムレイアウトは左右で対比を明確に
- フロー図はテキストベース（Mermaidは使わない）

## コードサンプル

### コードブロックの使用方針
**原則: コードブロックは極力使わず、図解・テキスト・箇条書きで説明**

理由:
- セミナーでコード自体を載せることのメリットが薄い
- 図解やテキストの方が理解しやすい
- 視覚的な情報量が多すぎると聴衆が疲れる

### 最小限のコードサンプル（必要な場合のみ）

#### コード1: DTOクラスの構造（5-7行程度）
テキストベースで説明し、必要に応じて以下の要素のみ提示:
- `@ApiProperty` デコレーター
- バリデーションデコレーター
- 型定義

**コードの代わりに図解・箇条書きで説明:**
- DTOクラスの役割: すべての型定義のマスター
- デコレーターから制約情報も自動抽出
- OpenAPI Specに自動変換

#### コード2: Orval設定の要点（テキストベース）
**コードの代わりに箇条書きで説明:**
- `mode: "single"` → 直接エクスポート
- `client: "axios-functions"` → パーツのみ生成（型定義 + Axios関数）
- Before/Afterは比較表で視覚化

#### コード3以降: すべて削除
**図解・テキストで置き換え:**
- カスタムSWRフック → 概念図とテキストで説明
- Mutation → フローとテキストで説明
- エラーハンドリング → 構造図とテキストで説明

## テーマ設定

### 使用するテーマ
- [x] `github-dark` - ダークテーマ（技術勉強会向け）

### テーマ選定理由
技術的な内容が中心で、コードサンプルが多いため、ダークテーマの方が視認性が高く、長時間の発表でも目が疲れにくい。

## タイミング・発表時間

### 想定発表時間
- 合計: 40分
  - Part 1: 10分（8枚）
  - Part 2: 15分（15枚）
  - Part 3: 10分（12枚）
  - まとめ: 5分（5枚）
  - Appendix: 時間外（必要に応じて参照）

### 1スライドあたりの時間
- 平均: 45-60秒/枚
- コードサンプルの多いスライド: 60-90秒/枚
- 表・数値の多いスライド: 60-90秒/枚

## デモ・実演

### デモ内容
なし（スライド発表のみ）

## インタラクティブ要素

### 聴衆への問いかけ
- スライド2（本日のゴール）: 「フロント・バックの型定義の不整合に悩んだ経験はありますか？」
- スライド5（Single Source of Truth）: 「DTOをマスターとする設計に共感できますか？」

## 参考資料・リンク

### スライド中で紹介するリンク
- モノレポ×AI協業環境構築術: https://tech-lab.sios.jp/archives/50109
- 自動化パイプライン記事: https://tech-lab.sios.jp/archives/49157
- Orval最適化記事: https://tech-lab.sios.jp/archives/49591
- 3フェーズ開発記事: https://tech-lab.sios.jp/archives/49140
- AI協働仕様書記事: https://tech-lab.sios.jp/archives/49148

### QRコード
なし（URLはテキストで記載）

## 補足資料

### 配布資料
なし

### 関連ブログ記事
- @docs/data/ai-development-methodology/tech-lab-sios-jp-archives-50109.html（モノレポ×AI協業環境構築術）
- @docs/data/technical-infrastructure/tech-lab-sios-jp-archives-49157.html（自動化パイプライン）
- @docs/data/technical-infrastructure/tech-lab-sios-jp-archives-49591.html（Orval最適化）

## 実装時の注意点

### 優先度
- 🔴 必須:
  - AI開発を効率化する環境整備の重要性
  - パーツ提供の考え方（型・関数の自動生成）
  - Single Source of Truth（人間もAIも迷わない設計）
  - 再定義のリスク排除による効率化
  - AIがハチャメチャなコードを出さなくなった実体験
  - 実測データ（70-79%効率化、20-30%バンドル削減）
- 🟡 推奨:
  - エラー型設計の重要性
  - 大規模プロジェクトでの運用課題
  - 移行中に発見したバグ
- 🟢 オプション:
  - axiosInstance vs axiosClientの区別（Appendixへ）
  - Appendixの詳細内容
  - よくある質問（追加Q&A）

### AIへの依頼事項
```
以下の仕様書を読み込んでMarpスライドを作成してください：
@docs/features/marp-automation-pipeline-seminar/spec.md

参考データ：
@docs/data/ai-development-methodology/tech-lab-sios-jp-archives-49140.html（3フェーズ開発）
@docs/data/ai-development-methodology/tech-lab-sios-jp-archives-49148.html（仕様書ベース開発）
@docs/data/ai-development-methodology/tech-lab-sios-jp-archives-49594.html（計画ドキュメント価値）
@docs/data/ai-development-methodology/tech-lab-sios-jp-archives-50103.html（4フェーズワークフロー）
@docs/data/ai-development-methodology/tech-lab-sios-jp-archives-50109.html（モノレポ×AI協業環境）
@docs/data/technical-infrastructure/tech-lab-sios-jp-archives-49157.html（自動化パイプライン）
@docs/data/technical-infrastructure/tech-lab-sios-jp-archives-49591.html（Orval最適化）

既存スライドの改善：
@application/marp/src/automation_pipeline_deep_dive_slides.md

実装方針：
- コアメッセージ「AI開発を効率化する環境整備」を最優先
- モノレポ構成の説明を追加（パイプライン構築の前提として必須）
- パーツ提供の思想（型・関数の自動生成）を強調
- 情報の順序と論理的な流れを重視（Part 1 → モノレポ → Part 2 → Part 3 → まとめ）
- レイアウトやデザインはあなたの判断で最適化
- テーマはgithub-darkを使用
- 1スライド1メッセージの原則を守る
- **コードブロックは極力使わない**（最小限の場合のみ5-7行程度）
- 図解・テキスト・箇条書きで説明する
- 表は見やすく、3-5行に抑える
- AIがハチャメチャなコードを出さなくなった実体験を強調
```

## 制約事項

### 技術的制約
- スライド枚数: 45-50枚（モノレポセクション追加により増加）
- 1スライドあたりの文字数: 150文字以内
- コードブロック: 15行以内
- 表: 3-5行、3-4列

### 発表環境
- オンライン・オフライン両対応
- プロジェクター投影を想定

## レビュー観点

実装後、以下を確認してください：

### メッセージの確認
- ✅ AI開発を効率化する環境整備の重要性が明確に伝わるか
- ✅ パーツ提供の考え方（shadcn/uiとの類似性）が理解できるか
- ✅ Single Source of Truthで人間もAIも迷わない設計が理解できるか
- ✅ AIがハチャメチャなコードを出さなくなった実体験が伝わるか
- ✅ 実測データ（70-79%効率化、20-30%バンドル削減）が示されているか

### ビジュアルの確認
- ✅ 図解（フロー図、比較表、構造図）は分かりやすいか
- ✅ **コードブロックは極力使っていないか**（最小限の場合のみ5-7行）
- ✅ テキスト・箇条書きで説明できているか
- ✅ 表は見やすいか（3-5行、3-4列）
- ✅ 1スライド1メッセージが守られているか

### タイミングの確認
- ✅ 想定40分に収まるか
- ✅ 各Partのバランスは適切か（10分、15分、10分、5分）
- ✅ コードブロックを減らすことで説明時間が短縮できているか

## 備考
- 既存スライド（automation_pipeline_deep_dive_slides.md）をベースに、コアメッセージを「AI開発の環境整備」に再構成
- **モノレポ構成の説明を追加**（パイプライン構築の前提として必須）
- データソース（3つのブログ記事: モノレポ、自動化パイプライン、Orval最適化）の内容を網羅的に反映
- **コードブロックは極力使わず、図解・テキスト中心の構成**
- 実測データ（47ファイル、4.2時間、70-79%効率化、20-30%バンドル削減）を強調
- AIがハチャメチャなコードを出さなくなった実体験を強調
- パーツ提供の思想（shadcn/uiとの類似性）を中心に据える
- エラー型設計の重要性を独立したセクションで強調
- モノレポ記事（50109）の内容を活用し、CLAUDE.md階層構造の概要を紹介
- Appendixを簡素化し、必要最小限の内容に絞る

---

## 仕様書レビューチェックリスト

実装前に以下を確認してください：

- [x] 伝えたいメッセージが4つ（AI環境整備、パーツ提供、Single Source of Truth、実測データ）に絞られているか
- [x] スライド構成が論理的に整理されているか（前提 → Spec一般論 → 3フェーズ → Part 1 → モノレポ → Part 2-3 → まとめ）
- [x] **モノレポ構成の説明が追加されているか**（パイプライン構築の前提として）
- [x] 図解が必要な箇所が特定されているか（18の図解: モノレポ4つ追加）
- [x] **コードブロックは極力使わず、図解・テキスト中心か**
- [x] 3フェーズ開発手法（計画→実装→検証）が同程度の分量で解説されているか
- [x] 4フェーズワークフロー（拡張版）が紹介されているか
- [x] Specベースのフレームワーク一般論が1枚程度にまとまっているか
- [x] CLAUDE.md階層構造の概要が紹介されているか
- [x] 1スライド1メッセージの原則が守られているか
- [x] 発表時間が現実的か（40-45分、45-50枚）
- [x] デザインの詳細（色、フォントサイズなど）を書いていないか
- [x] レイアウトの細かい指定を書いていないか
