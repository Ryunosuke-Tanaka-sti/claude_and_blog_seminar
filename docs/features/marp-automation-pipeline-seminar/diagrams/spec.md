# 図解仕様書：AI開発環境整備セミナー

## 概要

本仕様書は、「AI開発を効率化する環境整備術」セミナーで使用する図解の詳細仕様を定義します。

## 設計方針

### 基本原則

1. **GitHub Darkテーマとの統合**
   - スライドのGitHub Darkテーマと調和する配色・スタイル
   - **グラデーション禁止**: フラットな単色デザインのみ
   - テーマのCSS変数を活用（`.box.red`, `.box.green`, `.box.blue`など）

2. **シンプルなデザイン**
   - 既存SVG図解（diagram_3phase_flow.svg、diagram_automation_pipeline.svg、diagram_role_division.svg）のスタイルを踏襲
   - テキストベース優先: HTML/PNGよりもMarkdownのテキスト表現を優先
   - 2カラムレイアウト（`.two-columns`）を活用
   - ボックススタイル（`.box`）で視覚的な強調

3. **情報の明確性**
   - 1つの図解で1つの概念のみを表現
   - 比較は左右対比で明確に
   - フロー図はASCII/テキストベースで表現

### 使用可能な要素

#### Markdownスタイル
- `.two-columns` - 2カラムレイアウト
- `.box` - 基本ボックス
- `.box.red` - 問題点・Before（赤枠）
- `.box.green` - 改善点・After（緑枠）
- `.box.blue` - 補足・説明（青枠）
- `.box.yellow` - 注意・重要（黄枠）
- `.highlight` - ハイライト表示（紫グラデーション背景）
- テーブル（`table`）- 比較表・一覧表

#### 既存SVG図解
以下の高品質SVG図解は既に存在し、そのまま使用：
- `assets/diagram_3phase_flow.svg` - 3フェーズ開発手法
- `assets/diagram_automation_pipeline.svg` - 自動化パイプライン全体像
- `assets/diagram_role_division.svg` - 役割分担図（参考）

#### SVG図解の配色規則（新規作成時）
既存SVG図解の配色を踏襲する：
- **背景**: `#21262D` (GitHub Dark背景色)
- **メインカラー（枠線・アイコン）**: `#58A6FF` (青系)
- **テキスト**: `#C9D1D9` (グレー系)
- **アクセントカラー（必要時のみ）**:
  - 緑系: `#3FB950` (成功・改善点)
  - 赤系: `#F85149` (問題点・エラー)
  - 黄系: `#D29922` (警告・注意)
- **グラデーション禁止**: すべて単色のフラットデザイン
- **透明度**: 必要最小限のみ使用

## 図解リスト

### 1. Specフレームワーク一般論（テキスト・箇条書き）

**目的**: TDD、BDD、DbC、SDDの特徴を簡潔に紹介

**実装方法**: テキストベース（2カラムレイアウト）

**要素**:
- 左カラム: 主要フレームワーク（TDD、BDD、DbC、SDD）
- 右カラム: AI協働開発での活用（計画ドキュメント = Spec、2025年トレンド）

**配色**: テキストのみ、ボックス不要

---

### 2. ペアコーディングの課題（問題図）

**目的**: Vibe Codingの限界を示す

**実装方法**: テキストベース（赤・緑ボックス）

**要素**:
- 赤ボックス: 従来のペアコーディング（300文字で意図を伝えるのは困難）
- 緑ボックス: フェーズを分けることで役割を明確化

**配色**: `.box.red` / `.box.green`

---

### 3. 3フェーズ開発手法（フロー図）

**目的**: 計画→実装→検証のフローを示す

**実装方法**: 既存SVG図解を使用

**ファイル**: `assets/diagram_3phase_flow.svg`

---

### 3.5. 4フェーズワークフロー（拡張版フロー図）

**目的**: 計画→実装⇄研究→執筆のフローを示す

**実装方法**: ASCIIスタイルのテキストベース

**要素**:
```
【1. 計画】              【2. 実装】
docs/features/    →     application/
仕様書作成                コード実装
                              ⇅ 並行可能
                         【3. 研究】
                         docs/research/
                         知見ドキュメント化
                              ↓
                         【4. 執筆】
                         docs/article/
                         ブログ記事化
```

**配色**: テキストのみ

---

### 4. AIがハチャメチャなコードを出す3つの原因（問題図）

**目的**: 3つの原因を明確化

**実装方法**: テキストベース（赤ボックス × 3）

**要素**:
- 赤ボックス1: 原因1 - 型定義を再定義してしまう
- 赤ボックス2: 原因2 - エラー型が不明確
- 赤ボックス3: 原因3 - 過剰な自動生成

**配色**: `.box.red` × 3

---

### 5. 型定義の不整合（比較図）

**目的**: バックエンド（DTO）とフロントエンド（再定義）の不一致を示す

**実装方法**: テキストベース（2カラム + コードブロック最小限）

**要素**:
- 左カラム: バックエンド（DTO）の型定義
- 右カラム: フロントエンド（再定義）の型定義
- 下部: 結果（コンパイルは通るが、ランタイムでエラー）

**コードブロック**: 最大5-7行

**配色**: コードブロックのみ

---

### 5.5. 4つのアプリケーション（表）

**目的**: Frontend/Backend/Functions/MCP Functionsの技術スタックとデプロイ先を一覧表示

**実装方法**: Markdownテーブル

**要素**:
| アプリケーション | 技術スタック | デプロイ先 |
|---|---|---|
| Frontend | Next.js 15, React 19 | Azure Static Web Apps |
| Backend | NestJS 11, Node.js 22 | Azure Web Apps |
| X Scheduler | Azure Functions v4 | Azure Functions |
| MCP Functions | Azure Functions v4 | Azure Functions |

**配色**: テーブルスタイル（GitHub Dark標準）

---

### 5.6. 別リポジトリ vs モノレポ（比較図）

**目的**: AIのコンテキスト理解の違いを示す

**実装方法**: テキストベース（2カラム、赤・緑ボックス）

**要素**:
- 左カラム: 別リポジトリ（分散管理）
  - 赤ボックス × 3: コンテキスト分断、手動説明が必要、型定義の同期困難
- 右カラム: モノレポ（一元管理）
  - 緑ボックス × 3: 全体像を一度に提供、CLAUDE.md階層構造、型定義の自動同期

**配色**: `.box.red` × 3 / `.box.green` × 3

---

### 5.7. docs/とapplication/の分離（ディレクトリ構造）

**目的**: 計画と実装の明確な区別を示す

**実装方法**: テキストベース（コードブロック使用）

**要素**:
```
プロジェクトルート/
├── docs/                    # 計画・設計フェーズ
│   ├── features/            # 新機能開発計画
│   ├── research/            # 実装検証結果・知見
│   └── article/             # ブログ記事執筆用調査
├── application/             # 実装フェーズ
│   ├── backend/             # NestJS APIサーバー
│   ├── frontend/            # Next.js フロントエンド
│   └── functions/           # Azure Functions
└── infrastructure/          # IaCテンプレート
```

**配色**: コードブロックのみ

---

### 5.8. CLAUDE.md階層構造（階層図）

**目的**: ルート → サブディレクトリのコンテキスト継承を示す

**実装方法**: テキストベース（箇条書き + 説明）

**要素**:
- **ルート CLAUDE.md** → プロジェクト全体像
- **サブディレクトリ CLAUDE.md** → 各領域の詳細ルール
  - `/docs/CLAUDE.md` - 計画フェーズルール
  - `/application/backend/CLAUDE.md` - バックエンド開発ガイド
  - `/application/frontend/CLAUDE.md` - フロントエンド開発ガイド

**配色**: テキストのみ

---

### 6. パイプラインの全体像（フロー図）

**目的**: DTO → OpenAPI → 型・関数のパーツ化の流れを示す

**実装方法**: 既存SVG図解を使用

**ファイル**: `assets/diagram_automation_pipeline.svg`

---

### 7. DTO → OpenAPI Spec変換（概念図）

**目的**: DTOからOpenAPI Specへの変換プロセスを示す

**実装方法**: テキストベース（フロー + ハイライト）

**要素**:
- ハイライトボックス: Backend DTOs → OpenAPI Spec → Frontend Types
- 箇条書き: 自動生成による同期、AI協働開発との相性

**配色**: `.highlight`

---

### 8. エラー型の基本構造（構造図）

**目的**: RFC 7807準拠のエラーレスポンス構造を示す

**実装方法**: テキストベース（赤・緑ボックス）

**要素**:
- 赤ボックス: 問題点（エラー型が自動生成されない、`any`型になる）
- 緑ボックス: 解決策（RFC 7807準拠、必須フィールド）

**配色**: `.box.red` / `.box.green`

---

### 9. 生成される成果物（概念図）

**目的**: 型定義ファイル vs API関数の役割を示す

**実装方法**: テキストベース（箇条書き）

**要素**:
- **型定義ファイル**: DTOと1対1対応、Request/Response型
- **API呼び出し関数**: 型安全なAPI関数、Axios関数として提供

**配色**: テキストのみ

---

### 10. プロジェクト構成の最適化（ディレクトリ構造）

**目的**: CLAUDE.mdの配置とAIが触らないファイルを示す

**実装方法**: テキストベース（青ボックス + 箇条書き）

**要素**:
- 青ボックス: AIが触らないファイルの明確化
- 箇条書き: 自動生成ファイル（`lib/api/generated.ts`, `types/generated/`）

**配色**: `.box.blue`

---

### 11. すべてを自動生成する罠（問題図）

**目的**: 不要なコード生成の問題を示す

**実装方法**: テキストベース（赤ボックス）

**要素**:
- 赤ボックス: 発生した問題（バンドル肥大化、不要なオーバーヘッド、使わないコードが大量生成）

**配色**: `.box.red`

---

### 12. パーツ化のBefore / After（比較表）

**目的**: Before（全自動）とAfter（パーツのみ）の違いを示す

**実装方法**: テキストベース（2カラム、赤・緑ボックス）

**要素**:
- 左カラム: Before（全自動生成）
  - 赤ボックス: 問題点（全エンドポイント分のSWRフック生成、バンドルサイズ肥大化）
- 右カラム: After（必要なものだけ）
  - 緑ボックス: 改善点（型定義 + Axios関数のみ生成、SWRは必要な箇所のみ手動実装）

**配色**: `.box.red` / `.box.green`

---

### 13. 適材適所のアプローチ（フロー図）

**目的**: Read → SWR、CUD → Axiosの使い分けを示す

**実装方法**: テキストベース（2カラム、緑・青ボックス）

**要素**:
- 左カラム: Read（GET）: カスタムSWRフック
  - 緑ボックス: キャッシュ戦略、自動再検証、データ共有
- 右カラム: CUD（POST/PUT/DELETE）: 直接Axios
  - 青ボックス: シンプル実装、フォーム統合、一回限り

**配色**: `.box.green` / `.box.blue`

---

### 14. 移行結果の数値効果（表）

**目的**: バンドルサイズ、コード行数、移行工数を一覧表示

**実装方法**: Markdownテーブル

**要素**:
| 指標 | 実測データ |
|---|---|
| 対象範囲 | 47ファイル |
| 移行時間 | 推定14-20時間 → 実績4.2時間 |
| 効率化 | **70-79%効率化** |
| バンドルサイズ | 20-30%削減 |
| コード行数 | 約60%削減 |

**配色**: テーブルスタイル（GitHub Dark標準）

---

## 実装ルール

### 図解作成の優先順位

1. **テキストベースで表現可能な場合**: Markdown + CSSクラスを使用
2. **既存SVG図解が使用可能な場合**: 既存ファイルを参照
3. **新規SVG作成が必要な場合**: `assets/`に配置

### ファイル命名規則

- テキストベース図解: スライド本体（`.md`）に直接記述
- SVG図解: `src/assets/diagram_[name].svg`
- HTML図解（非推奨）: `src/html/[name].html`

### 禁止事項

- ❌ **グラデーション使用禁止**（紫グラデーションの`.highlight`を除く）
- ❌ HTML + Tailwind CSS + Playwright スクリーンショット方式（テーマとの統合が困難）
- ❌ 独立した背景を持つPNG画像（スライド背景と一体化しない）
- ❌ 複雑なレイアウトの図解（1つの図解で1つの概念）
- ❌ 既存SVG図解のスタイルと異なる配色やデザイン

### 推奨事項

- ✅ **既存SVG図解のスタイルを踏襲**（シンプルなフラットデザイン）
- ✅ GitHub Darkテーマの既存CSSクラスを活用
- ✅ 2カラムレイアウト（`.two-columns`）で比較表現
- ✅ ボックススタイル（`.box.red`, `.box.green`など）で視覚的強調
- ✅ 既存SVG図解の活用
- ✅ ASCIIスタイルのテキストベースフロー図
- ✅ 新規SVG作成時は配色規則に従う

---

## 検証計画

### 実装後の確認項目

1. **テーマとの統合**
   - ✅ スライド背景と一体化しているか
   - ✅ GitHub Darkテーマの配色と調和しているか
   - ✅ 文字が読みやすいか

2. **情報の明確性**
   - ✅ 1つの図解で1つの概念のみを表現しているか
   - ✅ 比較は左右対比で明確か
   - ✅ フロー図は理解しやすいか

3. **パフォーマンス**
   - ✅ ビルドが正常に完了するか
   - ✅ 画像のオーバーフローがないか
   - ✅ レイアウト崩れがないか

### ビルドコマンド

```bash
cd /home/node/workspace/application/marp
npm run build
```

### 確認方法

生成されたHTMLファイルを開いて視覚的に確認：
```bash
open dist/ai_development_environment_setup.html
```

---

## 成功基準

- 14個の図解がすべて実装されている
- GitHub Darkテーマと完全に統合されている
- テキストベース図解が優先的に使用されている
- 既存SVG図解（2個）が適切に参照されている
- ビルドエラーがない
- レイアウト崩れがない
- 情報が明確に伝わる

---

## 備考

- 本仕様書は `docs/features/marp-automation-pipeline-seminar/spec.md` の「図解・ビジュアル要素」セクションをもとに作成
- 実装は `application/marp/src/ai_development_environment_setup.md` で行う
- テーマファイル: `application/marp/theme/github-dark.css`
