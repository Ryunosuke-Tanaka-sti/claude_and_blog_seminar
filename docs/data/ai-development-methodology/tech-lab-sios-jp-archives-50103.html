<!--
ブログ記事情報:
タイトル: 【2025 年版】検証 → 記事化で知見を資産化！Claude Code×RAG もどきで AI 技術ブログ執筆を効率化
URL: https://tech-lab.sios.jp/archives/50103
OGP画像: https://tech-lab.sios.jp/wp-content/uploads/2025/11/7c52b26809ef9850857b982383708074.png
抽出日時: 2025-11-10T05:08:03.736Z
-->

<h1>【2025 年版】検証 → 記事化で知見を資産化！Claude Code×RAG もどきで AI 技術ブログ執筆を効率化</h1>


	
<div data-smooth-scroll="1" data-smooth-scroll-offset="24"><div><div><b>目次</b></div><div><ul><li><a href="#hajimeni"><span>1</span><span>はじめに</span></a><ul><li><a href="#ji_shino_wei_zhidzuke"><span>1.1</span><span>記事の位置づけ</span></a></li></ul></li><li><a href="#kono_ji_shide_xueberukoto"><span>2</span><span>この記事で学べること</span></a><ul><li><a href="#zhu_yaonapointo"><span>2.1</span><span>🎯 主要なポイント</span></a></li><li><a href="#shi_jian_denatekunikku"><span>2.2</span><span>💡 実践的なテクニック</span></a></li></ul></li><li><a href="#qian_ti_tiao_jian"><span>3</span><span>前提条件</span></a><ul><li><a href="#bi_yaona_zhi_shi"><span>3.1</span><span>必要な知識</span></a></li><li><a href="#aruto_li_jiega_shenmaru_zhi_shi"><span>3.2</span><span>あると理解が深まる知識</span></a></li><li><a href="#ben_ji_shide_xiwanaikoto"><span>3.3</span><span>本記事で扱わないこと</span></a></li></ul></li><li><a href="#4_fezuwakufurono_fu_xi"><span>4</span><span>4 フェーズワークフローの復習</span></a><ul><li><a href="#4_fezuno_gai_yao"><span>4.1</span><span>4 フェーズの概要</span></a></li><li><a href="#fezu_1-2_ji_huato_shi_zhuang_gai_yao"><span>4.2</span><span>フェーズ 1-2: 計画と実装（概要）</span></a></li><li><a href="#ben_ji_shino_jiao_dian_fezu_3-4"><span>4.3</span><span>本記事の焦点: フェーズ 3-4</span></a></li></ul></li><li><a href="#fezu_3_yan_jiu_ji_luno_shi_jian"><span>5</span><span>フェーズ 3: 研究記録の実践</span></a><ul><li><a href="#yan_jiu_ji_lufezuno_mu_de"><span>5.1</span><span>研究記録フェーズの目的</span></a></li><li><a href="#direkutori_gou_zao"><span>5.2</span><span>ディレクトリ構造</span></a></li><li><a href="#yan_jiu_ji_luni_ji_zaisuru_nei_rong"><span>5.3</span><span>研究記録に記載する内容</span></a><ul><li><a href="#ji_zaisubeki_nei_rong"><span>5.3.1</span><span>✅ 記載すべき内容</span></a></li><li><a href="#ji_zaishinai_nei_rong"><span>5.3.2</span><span>❌ 記載しない内容</span></a></li></ul></li><li><a href="#shi_jino_yan_jiu_ji_lu_li"><span>5.4</span><span>実際の研究記録例</span></a></li></ul></li><li><a href="#fezu_4_ji_shi_huano_shi_jian"><span>6</span><span>フェーズ 4: 記事化の実践</span></a><ul><li><a href="#ji_shi_huafezuno_mu_de"><span>6.1</span><span>記事化フェーズの目的</span></a></li><li><a href="#direkutori_gou_zao1"><span>6.2</span><span>ディレクトリ構造</span></a></li><li><a href="#research-docmd_diao_zha_zi_liaono_gou_cheng"><span>6.3</span><span>research-doc.md（調査資料）の構成</span></a></li></ul></li><li><a href="#RAG_modoki_burogu_HTML_chou_chutsuru"><span>7</span><span>RAG もどき: ブログ HTML 抽出ツール</span></a><ul><li><a href="#RAG_modokitoha"><span>7.1</span><span>RAG もどきとは？</span></a></li><li><a href="#naze_RAG_modokiga_bi_yaoka"><span>7.2</span><span>なぜ RAG もどきが必要か？</span></a></li><li><a href="#fetch-blog-htmlts_no_ji_neng"><span>7.3</span><span>fetch-blog-html.ts の機能</span></a><ul><li><a href="#ru_lichu_li"><span>7.3.1</span><span>入力・出力</span></a></li><li><a href="#chu_li_gai_yao"><span>7.3.2</span><span>処理概要</span></a></li><li><a href="#shi_xing_jie_guo_li"><span>7.3.3</span><span>実行結果例</span></a></li></ul></li><li><a href="#tokun_shu_xue_jian_xiao_guo"><span>7.4</span><span>トークン数削減効果</span></a></li><li><a href="#RAG_modokino_huo_yong_fang_fa"><span>7.5</span><span>RAG もどきの活用方法</span></a><ul><li><a href="#1_ji_cun_ji_shino_yi_lan_que_ren"><span>7.5.1</span><span>1. 既存記事の一覧確認</span></a></li><li><a href="#2_ji_shi_zhi_bi_shini_ji_cun_ji_shiwo_can_zhao"><span>7.5.2</span><span>2. 記事執筆時に既存記事を参照</span></a></li></ul></li><li><a href="#RAG_modokinomeritto"><span>7.6</span><span>RAG もどきのメリット</span></a></li></ul></li><li><a href="#wen_ti_bu_zheng_writing-style-promptmd"><span>8</span><span>文体補正: writing-style-prompt.md</span></a><ul><li><a href="#wen_ti_bu_zhengshisutemutoha"><span>8.1</span><span>文体補正システムとは？</span></a></li></ul></li><li><a href="#shi_jian_li_shi_jino_zhi_bipurosesu"><span>9</span><span>実践例: 実際の執筆プロセス</span></a><ul><li><a href="#suteppu_1_ji_shinoaideawozakkuri_shuku"><span>9.1</span><span>ステップ 1: 記事のアイデアをざっくり書く</span></a></li><li><a href="#suteppu_2_can_zhaodokyumentoto_shi_zhuangwo_diao_zha"><span>9.2</span><span>ステップ 2: 参照ドキュメントと実装を調査</span></a></li><li><a href="#suteppu_3_puronputotoshite_qing_baowo_dusu"><span>9.3</span><span>ステップ 3: プロンプトとして情報を渡す</span></a></li><li><a href="#suteppu_4_ji_shi_ben_wen_zhi_bitorebyu"><span>9.4</span><span>ステップ 4: 記事本文執筆とレビュー</span></a></li></ul></li><li><a href="#yokuaru_ke_tito_jie_jue_fa"><span>10</span><span>よくある課題と解決法</span></a><ul><li><a href="#ke_ti_1_diao_zha_zi_liaoga_zhangsugite_AI_ga_hun_luan"><span>10.1</span><span>課題 1: 調査資料が長すぎて AI が混乱</span></a></li><li><a href="#ke_ti_2_ji_shi_zhi_bini_shi_jiangakakarisugiru"><span>10.2</span><span>課題 2: 記事執筆に時間がかかりすぎる</span></a></li></ul></li><li><a href="#wakufuro_quan_tino_xiao_guo"><span>11</span><span>ワークフロー全体の効果</span></a><ul><li><a href="#ding_liang_dena_xiao_guo"><span>11.1</span><span>定量的な効果</span></a></li><li><a href="#kai_fa_zheno_sheng_longchanno_shi_ti_yan"><span>11.2</span><span>開発者の声（龍ちゃんの実体験）</span></a></li><li><a href="#wakufuro_quan_tino_xiao_guomatome"><span>11.3</span><span>ワークフロー全体の効果まとめ</span></a></li></ul></li><li><a href="#matome"><span>12</span><span>まとめ</span></a><ul><li><a href="#jian_zheng_ji_shi_huawakufuronopointo"><span>12.1</span><span>検証 → 記事化ワークフローのポイント</span></a></li><li><a href="#xiao_guomatome"><span>12.2</span><span>効果まとめ</span></a></li><li><a href="#cinosuteppu"><span>12.3</span><span>次のステップ</span></a></li></ul></li><li><a href="#can_kaorinku"><span>13</span><span>参考リンク</span></a><ul><li><a href="#gong_shidokyumento"><span>13.1</span><span>公式ドキュメント</span></a></li></ul></li></ul></div></div></div><h2><span>はじめに</span></h2><p>ども！最近は Claude Code とべったりで、実装 → 検証 → 記事化のサイクルを回している龍ちゃんです。</p><p>皆さん、せっかく実装して検証した知見、<strong>ちゃんと記事化できてますか？</strong></p><p>僕も以前はこんな悩みを抱えていました：</p><ul><li><strong>実装完了後に「記事書こう」と思っても、何を書けばいいか分からない</strong></li><li><strong>実装時のメモが散らばって、記事執筆時に情報を集めるのが大変</strong></li><li><strong>既存記事との整合性を取るのが面倒で、似たような内容を書いてしまう</strong></li></ul><p>特に困ったのが、<strong>実装から時間が経つと、なぜその設計にしたのか忘れてしまう</strong>こと。「あれ、これってどういう意図だったっけ？」とコードを読み返す羽目になり、記事執筆が進まない…。</p><p>そこで構築したのが、<strong>検証 → 記事化をワンセットにしたワークフロー</strong>です。この仕組みにより、以下の成果を得られました：</p><p>✅ <strong>知見が自然に蓄積</strong>（実装と同時にドキュメント化）<br>✅ <strong>記事執筆時間 50%削減</strong>（調査資料が既に揃っている）<br>✅ <strong>既存記事との整合性確保</strong>（RAG もどきで既存記事を参照）</p><p>この記事では、<strong>実装完了後の知見をブログ記事化する仕組み</strong>を、実際のプロジェクト例とツールを交えながら解説していきます。</p><h3><span>記事の位置づけ</span></h3><p>この記事は、既存の<strong>3 フェーズ開発フロー（計画 → 実装 → 検証）</strong>を拡張し、<strong>検証後の知見を記事化するフェーズ</strong>に焦点を当てた内容です。</p><h2><span>この記事で学べること</span></h2><p>この記事を読むことで、以下の知識とスキルが得られます：</p><h3><span>🎯 主要なポイント</span></h3><ol><li><strong>フェーズ 3: 研究記録の実践</strong><br>実装完了後の知見をどう記録するか（<code>/docs/research/</code>）</li><li><strong>フェーズ 4: 記事化の実践</strong><br>調査資料から記事本文への変換方法（<code>/docs/article/</code>）</li><li><strong>RAG もどき: ブログ HTML 抽出ツール</strong><br>既存記事をローカルに保存し、記事執筆時に参照する仕組み</li><li><strong>文体補正システム</strong><br>writing-style-prompt.md による一貫した記事品質</li></ol><h3><span>💡 実践的なテクニック</span></h3><ul><li>research-doc.md（調査資料）の書き方</li><li>no1-article.md（記事本文）への変換パターン</li><li>fetch-blog-html.ts による既存記事参照</li><li>トークン数削減テクニック（50-60%削減）</li></ul><h2><span>前提条件</span></h2><h3><span>必要な知識</span></h3><ul><li><strong>AI 開発ツールの使用経験</strong></li><li>Claude Code、GitHub Copilot、Cursor 等の AI 開発支援ツールを使った開発経験</li><li>AI にプロンプトを投げてコードを生成した経験</li></ul><h3><span>あると理解が深まる知識</span></h3><ul><li><strong>3 フェーズ開発フローの概念</strong></li><li>計画 → 実装 → 検証の基本的な流れへの理解</li><li>以下の記事を参照:
<ul><li><a href="https://tech-lab.sios.jp/archives/49140">Claude Code 革命！3 フェーズ開発で効率的な開発：計画 → 実装 → 検証術</a></li><li><a href="https://tech-lab.sios.jp/archives/49148">AI 協働で仕様書アレルギー克服！開発時間を 1 週間 →2 日に短縮する実践法</a></li></ul></li></ul><h3><span>本記事で扱わないこと</span></h3><p>❌ 3 フェーズ開発フロー全体の詳細（上記参照記事を参照）<br>❌ Markdown 記法の基礎<br>❌ ブログプラットフォーム（Hashnode 等）の使い方</p><p>本記事は、<strong>フェーズ 3→4（検証 → 記事化）のワークフロー</strong>に焦点を当てています。</p><h2><span>4 フェーズワークフローの復習</span></h2><p>まずは、4 フェーズワークフローの全体像を確認しましょう。</p><h3><span>4 フェーズの概要</span></h3><figure><img data-recalc-dims="1" decoding="async" width="880" height="585" src="https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/11/820942403bb694d3f8954c296e61935d.png?resize=880%2C585&amp;ssl=1" srcset="https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/11/820942403bb694d3f8954c296e61935d.png?w=1920&amp;ssl=1 1920w, https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/11/820942403bb694d3f8954c296e61935d.png?resize=1536%2C1022&amp;ssl=1 1536w, https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/11/820942403bb694d3f8954c296e61935d.png?resize=940%2C625&amp;ssl=1 940w, https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/11/820942403bb694d3f8954c296e61935d.png?w=1760&amp;ssl=1 1760w" sizes="(max-width: 880px) 100vw, 880px">  (https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/11/820942403bb694d3f8954c296e61935d.png?resize=880%2C585&amp;ssl=1) </figure><h3><span>フェーズ 1-2: 計画と実装（概要）</span></h3><p><strong>フェーズ 1: 計画</strong>（<code>/docs/features/</code>）</p><ul><li>目的: 実装前の設計・仕様策定</li><li>成果物: 型定義、API 設計、データベース構造</li></ul><p><strong>フェーズ 2: 実装</strong>（<code>/application/</code>）</p><ul><li>目的: 計画に基づいた実装</li><li>成果物: 動作するコード</li></ul><p>詳細は以下の記事を参照してください：</p><ul><li><a href="https://tech-lab.sios.jp/archives/49140">Claude Code 革命！3 フェーズ開発で効率的な開発：計画 → 実装 → 検証術</a></li><li><a href="https://tech-lab.sios.jp/archives/49148">AI 協働で仕様書アレルギー克服！開発時間を 1 週間 →2 日に短縮する実践法</a></li></ul><h3><span>本記事の焦点: フェーズ 3-4</span></h3><p>本記事では、<strong>実装完了後の知見を記事化するフェーズ 3-4</strong>に焦点を当てます。</p><p><strong>フェーズ 3: 研究記録</strong>（<code>/docs/research/</code>）</p><ul><li>実装完了後の知見・検証結果をドキュメント化</li><li>設計思想、アーキテクチャパターン、検証結果を記録</li></ul><p><strong>フェーズ 4: 記事化</strong>（<code>/docs/article/</code>）</p><ul><li>技術ブログ執筆に必要な情報収集</li><li>research-doc.md（調査資料）→ no1-article.md（記事本文）の変換</li></ul><h2><span>フェーズ 3: 研究記録の実践</span></h2><h3><span>研究記録フェーズの目的</span></h3><p>実装完了後、<strong>「なぜその設計にしたのか」「どんな課題があって、どう解決したのか」</strong>を記録するフェーズです。</p><p><strong>目的</strong>:</p><ul><li>設計思想と意思決定の記録</li><li>アーキテクチャパターンの検証結果</li><li>実装完了後の振り返り</li></ul><p><strong>記録先</strong>: <code>/docs/research/</code></p><h3><span>ディレクトリ構造</span></h3><p>研究記録は、単一ファイル形式で管理します（小〜中規模機能に対応）。</p><div><pre data-lang="Bash"><code>docs/research/
├── aoai-chat-simple.md              # Azure OpenAI チャット機能
├── github-api-integration.md        # GitHub API 統合
└── csv-preview-system.md            # CSV プレビュー機能</code></pre></div><p><strong>特徴</strong>: 1 ファイルで機能検証が完結し、効率的に参照・更新できます。</p><h3><span>研究記録に記載する内容</span></h3><h4><span>✅ 記載すべき内容</span></h4><ul><li>設計思想と意思決定（なぜその設計を選択したか）</li><li>主要エンドポイントの概要（ファイルパス参照）</li><li>検証結果（パフォーマンス、エッジケース）</li></ul><h4><span>❌ 記載しない内容</span></h4><ul><li>ソースコードの全文転記</li><li>詳細な実装手順</li><li>機密情報（API キー、認証情報）</li></ul><h3><span>実際の研究記録例</span></h3><p>このプロジェクトには、20 件の研究記録があります：</p><p><strong>単一ファイル形式の例</strong>:</p><ul><li><code>aoai-chat-simple.md</code> – Azure OpenAI チャット機能</li><li><code>github-api-integration.md</code> – GitHub API 統合</li><li><code>csv-preview-system.md</code> – CSV プレビュー機能</li></ul><p><strong>ディレクトリ形式の例</strong>:</p><ul><li><code>supabase-x-scheduler-v2/</code> – X 投稿スケジューラーの大規模リファクタリング</li><li><code>api-generation-pipeline/</code> – OpenAPI 自動生成パイプライン</li><li><code>frontend-refactoring/</code> – フロントエンド大規模リファクタリング</li></ul><h2><span>フェーズ 4: 記事化の実践</span></h2><h3><span>記事化フェーズの目的</span></h3><p>研究記録をもとに、<strong>技術ブログ執筆に必要な情報を収集・整理</strong>するフェーズです。</p><p><strong>目的</strong>:</p><ul><li><code>/docs/features/</code>（計画）+ <code>/docs/research/</code>（検証）+ <code>/application/</code>（実装）から情報を抽出</li><li>読者向けに再構成</li><li>記事構成案とコードスニペットを整理</li></ul><p><strong>記録先</strong>: <code>/docs/article/</code></p><h3><span>ディレクトリ構造</span></h3><div><pre data-lang="Bash"><code>docs/article/
├── CLAUDE.md                        # 記事執筆ガイドライン
├── writing-style-prompt.md          # 文体スタイルガイド
└── {article-topic}/                 # ケバブケース命名
    ├── research-doc.md              # 必須 - 調査資料
    ├── no1-article.md               # 必須 - 記事本文
    ├── no2-article.md               # 任意 - 続編がある場合
    └── image/                       # 必須 - 画像ファイル格納（.gitignore除外）
        ├── screenshot.png
        └── diagram.png</code></pre></div><p><strong>重要なルール</strong>:</p><ul><li><code>research-doc.md</code> は必須（リポジトリ内容の調査結果）</li><li><code>image/</code> サブディレクトリは必須（<code>.gitignore</code>で除外済み）</li><li>ディレクトリ名はケバブケース（<code>x-post-with-oauth</code>, <code>azure-functions-local-setup</code>）</li></ul><h3><span>research-doc.md（調査資料）の構成</span></h3><p>調査資料は、記事執筆の基礎資料となります。主要セクション：</p><ul><li><strong>記事概要</strong>: 対象読者、目的、キーワード</li><li><strong>参照元ドキュメント</strong>: 計画/検証/実装のファイルパス</li><li><strong>技術スタック</strong>: 使用技術とバージョン</li><li><strong>実装の要点</strong>: 主要機能の概要とコードスニペット候補</li><li><strong>技術的な課題と解決策</strong>: 問題、解決策、参考実装</li><li><strong>記事構成案</strong>: H1/H2/H3 レベルの見出し構造</li><li><strong>図表・資料</strong>: 必要な図表のチェックリスト</li></ul><h2><span>RAG もどき: ブログ HTML 抽出ツール</span></h2><h3><span>RAG もどきとは？</span></h3><p><strong>RAG（Retrieval-Augmented Generation）</strong>は、ベクトル検索で外部知識を自動取得し、AI が回答を生成する仕組みです。</p><p>このプロジェクトでは、<strong>既存のブログ記事をローカルに保存</strong>し、<strong>手動で選択して</strong>新規記事執筆時に参照する「<strong>RAG もどき</strong>」を構築しています。</p><p><strong>RAG との違い</strong>:</p><ul><li>本物の RAG: ベクトル化 + セマンティック検索（自動）</li><li>RAG もどき: HTML ファイル保存 + 手動参照</li></ul><p>シンプルですが、文体補正や既存記事との整合性確保には十分効果的です。</p><h3><span>なぜ RAG もどきが必要か？</span></h3><p>記事執筆時にこんな課題がありました：</p><p>❌ <strong>既存記事と似た内容を書いてしまう</strong><br>❌ <strong>既存記事との整合性を取るのが大変</strong><br>❌ <strong>過去の記事タイトルや文体を忘れてしまう</strong></p><p>そこで、<code>fetch-blog-html.ts</code> を使って<strong>既存記事をローカルに保存</strong>し、記事執筆時に参照できるようにしました。</p><h3><span>fetch-blog-html.ts の機能</span></h3><p>これは TypeScript である必要は全くありません。好きな言語で実装してください。こちらのファイルの肝となる部分は、ツールとして渡すことでトークン数を削減しながら既存のデータを保存できるという点です。</p><h4><span>入力・出力</span></h4><p><strong>入力</strong>: 環境変数 <code>URL</code> でブログ記事 URL を指定</p><div><pre data-lang="Bash"><code># /docs ディレクトリで実行
cd /home/node/dev/docs
URL="https://tech-lab.sios.jp/archives/49157" npm run fetch-blog</code></pre></div><p><strong>出力</strong>: <code>/docs/tools/doc/tech-lab-sios-jp-archives-49157.html</code></p><h4><span>処理概要</span></h4><p>既存のブログ記事から HTML を取得し、以下の処理を行います：</p><div><ul><li>記事本文のみを抽出（不要なヘッダー、フッター、サイドバーを除去）</li><li>画像をテキスト化（alt 属性と URL を保持）</li><li>不要な属性・空白を削除</li><li>トークン数を計算</li></ul></div><p><strong>実装コード</strong>: TypeScript実装を公開しています</p><ul><li><a href="https://gist.github.com/Ryunosuke-Tanaka-sti/01125c8c95da1ce7dcb5f315ab243c3c">fetch-blog-html.ts (GitHub Gist)</a></li><li>SIOS Tech Lab ブログ用にカスタマイズされています</li><li>他のブログにも応用可能（セレクタ部分を調整）</li></ul><h4><span>実行結果例</span></h4><p>実際に記事 49157（Next.js×Nest.js 型定義同期）を抽出した結果がこちらです：</p><p><strong>出力ファイル</strong>: <code>/docs/tools/doc/tech-lab-sios-jp-archives-49157.html</code>（部分抜粋）</p><div><pre data-lang="HTML"><code>&lt;!--
ブログ記事情報:
タイトル: AIと爆速開発！Next.js×Nest.js型定義同期の自動生成パイプライン構築術 | SIOS Tech. Lab
URL: https://tech-lab.sios.jp/archives/49157
OGP画像: https://tech-lab.sios.jp/wp-content/uploads/2025/09/572995517b0ce827aa745786a62911c5.png
抽出日時: 2025-10-30T01:55:41.785Z
--&gt;

&lt;h1&gt;
  AIと爆速開発！Next.js×Nest.js型定義同期の自動生成パイプライン構築術 | SIOS
  Tech. Lab
&lt;/h1&gt;

&lt;h2&gt;初めに&lt;/h2&gt;
&lt;p&gt;
  AIと一緒に開発をするようになってから、フロントエンドとバックエンド両方を爆速で開発することができるようになって、検証が爆速で進むようになった龍ちゃんです。
&lt;/p&gt;

&lt;p&gt;AIが混乱しないようにプロジェクト自体を整備する方法についてお話しします。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;a href="https://tech-lab.sios.jp/archives/49140"
      &gt;Claude Code革命！3フェーズ開発で効率的な開発：計画→実装→検証術&lt;/a
    &gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href="https://tech-lab.sios.jp/archives/49148"
      &gt;AI協働で仕様書アレルギー克服！開発時間を1週間→2日に短縮する実践法&lt;/a
    &gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 画像はURLのみ保持 --&gt;
&lt;figure&gt;
  &lt;img
    src="https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/b060e7bc0582b2a27f7c9de8a921557f.png"
  /&gt;
  (https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/b060e7bc0582b2a27f7c9de8a921557f.png)
&lt;/figure&gt;

&lt;!-- ...中略... --&gt;

&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;
  正直、これは導入してみて一番良かったなと思える点ですね。ルールをあまり追加させずにAIに生成させるコードが圧倒的にきれいになりました。
&lt;/p&gt;</code></pre></div><p><strong>抽出された HTML の特徴</strong>:</p><p>✅ OGP 情報（タイトル、URL、画像、抽出日時）をコメントで記録</p><p>✅ 記事の構造（見出し、段落、リスト）を完全保持</p><p>✅ 画像は URL のみ保存（Claude Code で参照可能）</p><p>✅ 不要なヘッダー、フッター、サイドバーを除去</p><p>✅ 龍ちゃんの文体（「ども！」）も維持</p><h3><span>トークン数削減効果</span></h3><p><strong>実測値</strong>（既存記事 17 件の平均）:</p><div><figure><table><thead><tr><th>指標</th><th>削減率</th></tr></thead><tbody><tr><td><strong>抽出による削減</strong></td><td>40-50%</td></tr><tr><td><strong>圧縮による削減</strong></td><td>10-15%</td></tr><tr><td><strong>総合圧縮率</strong></td><td>50-60%</td></tr></tbody></table></figure></div><p><strong>具体例</strong>（記事 49157: 型安全パイプライン）:</p><div><pre><code>元ページ全体のトークン数: 35,420
抽出後のトークン数: 18,250（48.5%削減）
最終圧縮後のトークン数: 15,680（14.1%削減）
総削減トークン数: 19,740（55.7%削減）</code></pre></div><h3><span>RAG もどきの活用方法</span></h3><h4><span>1. 既存記事の一覧確認</span></h4><div><pre data-lang="Bash"><code>ls /home/node/dev/docs/tools/doc/</code></pre></div><p>抽出済みの記事を一覧で確認し、類似テーマの記事を探します。</p><h4><span>2. 記事執筆時に既存記事を参照</span></h4><p>類似テーマの既存記事を選択し、Claude Code に読み込ませます。</p><div><pre data-lang="Markdown"><code># プロンプト例

この記事から発展して、次の記事を考案したいので読み込んでください。

**既存記事**: [抽出済みの HTML ファイル]
**文体ガイド**: /docs/article/writing-style-prompt.md
**記事の位置づけ**: [シリーズ構成、関連記事との関係]</code></pre></div><p>既存記事（HTML）+ 文体ガイド（writing-style-prompt.md）+ 記事の位置づけを読み込ませることで、<strong>一貫した記事品質</strong>と<strong>シリーズとしての連続性</strong>を維持できます。</p><h3><span>RAG もどきのメリット</span></h3><p>✅ <strong>既存記事との重複チェック</strong><br>既存記事を参照することで、似た内容を書くことを防げる</p><p>✅ <strong>文体・構成の一貫性</strong><br>既存記事のスタイルを参考に、統一された記事品質を維持</p><p>✅ <strong>トークン数削減（50-60%）</strong><br>記事をローカルに保存し、コード化することでトークン数を大幅削減。Claude Code への入力が効率化される</p><p>✅ <strong>不要な記事取得の軽減</strong><br>記事化している情報をローカルに落とすことで、都度 Web から取得する手間を削減</p><p>✅ <strong>オフライン参照</strong><br>インターネット接続なしで既存記事を参照可能</p><p>✅ <strong>将来の完全自動化への布石</strong><br>システムプロンプトを育てることで、検証 → 記事化のナレッジ化まで完全自動化も夢じゃない！</p><h2><span>文体補正: writing-style-prompt.md</span></h2><h3><span>文体補正システムとは？</span></h3><p><strong>writing-style-prompt.md</strong>は、記事を執筆するための文体ガイドです。</p><p><strong>仕組み</strong>:</p><ol><li><strong>既存記事から文体を抽出</strong>: 投稿済みの記事を分析し、文体パターンをプロンプト化</li><li><strong>プロセス化</strong>: 新しい記事を投稿するたびに、文体ガイドをレビュー・更新</li><li><strong>レビュー用システムプロンプトを育てる</strong>: 継続的な改善で精度向上</li></ol><p><strong>メリット</strong>:</p><ul><li>一貫した記事品質の維持</li><li>AI が文体を学習し、自動的にスタイルに合った記事を生成</li><li>記事執筆時のレビュー観点が明確化</li></ul><h2><span>実践例: 実際の執筆プロセス</span></h2><p>本ワークフローの実際の執筆フローを解説します。</p><h3><span>ステップ 1: 記事のアイデアをざっくり書く</span></h3><p>まず、<strong>書きたいことを適当でよいのでざっくり書きます</strong>。</p><ul><li>記事タイトル案</li><li>伝えたいポイント（箇条書き）</li><li>想定する読者</li><li>記事の位置づけ（シリーズ構成等）</li></ul><p>この段階では完璧である必要はありません。アイデアをラフに整理するだけです。</p><h3><span>ステップ 2: 参照ドキュメントと実装を調査</span></h3><p>ざっくり書いた内容をもとに、<strong>参照すべきドキュメントや実装を調査</strong>します。</p><p>調査資料（research-doc.md）に以下を整理：</p><ul><li>参照元ドキュメント（計画、検証、実装のファイルパス）</li><li>技術スタック</li><li>実装の要点（コードスニペット候補）</li><li>技術的な課題と解決策</li></ul><h3><span>ステップ 3: プロンプトとして情報を渡す</span></h3><p>記事執筆時に<strong>プロンプトとして以下を渡します</strong>：</p><ul><li>参照記事（fetch-blog-html.ts で取得した HTML）</li><li>記事の位置づけ（シリーズ構成、関連記事との関係）</li><li>writing-style-prompt.md（文体ガイド）</li><li>research-doc.md（調査資料）</li></ul><p>Claude Code にこれらを読み込ませ、記事本文（no1-article.md）を執筆します。</p><h3><span>ステップ 4: 記事本文執筆とレビュー</span></h3><p>Claude Code にプロンプトを渡し、<code>no1-article.md</code> を執筆します。</p><p>執筆後のレビュー項目：</p><ul><li>参照記事との整合性チェック</li><li>定量的データの妥当性チェック</li><li>文体チェック（writing-style-prompt.md と照合）</li></ul><h2><span>よくある課題と解決法</span></h2><h3><span>課題 1: 調査資料が長すぎて AI が混乱</span></h3><p><strong>問題</strong>: research-doc.md が長すぎると（2000 行以上）、AI が全体を把握しづらくなる。</p><p><strong>解決策</strong>:</p><ul><li>ディレクトリ形式に分割（research-doc.md, architecture.md, implementation.md）</li><li>セクションごとに記事を分割（no1-article.md: 基礎編、no2-article.md: 応用編）</li></ul><h3><span>課題 2: 記事執筆に時間がかかりすぎる</span></h3><p><strong>問題</strong>: 調査資料から記事本文への変換に時間がかかる（4-5 時間）。</p><p><strong>解決策</strong>:</p><ul><li>テンプレートを活用（はじめに、Before/After セクション）</li><li>AI に変換を依頼（writing-style-prompt.md + Mermaid 図 + Before/After 比較）</li><li>段階的に執筆（導入 → 本編 → まとめ）</li></ul><h2><span>ワークフロー全体の効果</span></h2><h3><span>定量的な効果</span></h3><div><figure><table><thead><tr><th>指標</th><th>Before</th><th>After</th><th>改善率</th></tr></thead><tbody><tr><td><strong>記事執筆時間</strong></td><td>8 時間</td><td>4 時間</td><td>50%削減</td></tr><tr><td><strong>調査時間</strong></td><td>2 時間</td><td>1 時間</td><td>50%削減</td></tr><tr><td><strong>既存記事重複チェック</strong></td><td>手動（30 分）</td><td>簡易 RAG（5 分）</td><td>83%削減</td></tr><tr><td><strong>記事品質（一貫性）</strong></td><td>60%（主観）</td><td>90%（主観）</td><td>50%向上</td></tr></tbody></table></figure></div><p><strong>※測定条件</strong>: 中規模記事（800-1000 行）での実測値</p><h3><span>開発者の声（龍ちゃんの実体験）</span></h3><p><strong>導入後の変化</strong>:</p><p>この機能を導入して、ブログを書くっていう行為がまた一つ変わりました。検証した内容からそのままブログ化できるっていうのは本当に便利で、動くコードがそのままブログに転写できるようになったのは大きいですね。</p><p><strong>意識的な変化</strong>:</p><p>ただ、使うにあたって気づいたのが、「明確な意図を持って検証する」必要が出てきたということです。今までは頭の中でやっていた作業を、ちゃんとドキュメント化しなきゃいけない。結構頭を使うようになりました。</p><p><strong>Before → After</strong>:</p><ul><li><strong>導入前</strong>: 現象を後から眺めて「ブログ書くか」みたいな感じ</li><li><strong>導入後</strong>: 検証の過程を全部ドキュメント化</li><li>「何を考えてこうやってみたのか」</li><li>「実際どうなったのか」</li><li>「最初の予想と結論の違い」</li></ul><p>これ全部ドキュメントに残さなきゃいけないので、検証を明確な意識を持って行うようになりました。</p><p><strong>全体的な感想</strong>:</p><p>インプットもアウトプットも、AI が入ってきて変わったなと素直に思ってます。</p><h3><span>ワークフロー全体の効果まとめ</span></h3><p>✅ <strong>知見が自然に蓄積</strong><br>実装と同時にドキュメントが作成される</p><p>✅ <strong>記事執筆時間 50%削減</strong><br>調査資料が既に揃っている</p><p>✅ <strong>既存記事との整合性確保</strong><br>簡易 RAG（fetch-blog-html.ts）で既存記事を参照</p><p>✅ <strong>記事品質の向上</strong><br>writing-style-prompt.md で一貫した文体</p><p>✅ <strong>記事化のハードルが下がる</strong><br>「記事書こう」と思った時に、すぐに書き始められる</p><h2><span>まとめ</span></h2><p>この記事では、<strong>検証 → 記事化ワークフローの実践方法</strong>を解説しました。</p><h3><span>検証 → 記事化ワークフローのポイント</span></h3><p>✅ <strong>フェーズ 3: 研究記録（/docs/research/）</strong><br>実装完了後の知見・検証結果をドキュメント化</p><p>✅ <strong>フェーズ 4: 記事化（/docs/article/）</strong><br>調査資料（research-doc.md）→ 記事本文（no1-article.md）の変換</p><p>✅ <strong>RAG もどきシステム: fetch-blog-html.ts</strong><br>既存記事をローカルに保存し、記事執筆時に参照（トークン数 50-60%削減）</p><p>✅ <strong>文体補正: writing-style-prompt.md</strong><br>一貫した記事品質を維持</p><h3><span>効果まとめ</span></h3><div><figure><table><thead><tr><th>Before</th><th>After</th></tr></thead><tbody><tr><td>記事執筆時間 8 時間</td><td>調査資料活用で 4 時間（50%削減）</td></tr><tr><td>既存記事重複チェック手動（30 分）</td><td>簡易 RAG で 5 分（83%削減）</td></tr><tr><td>記事品質バラバラ</td><td>文体補正で一貫性 90%（主観）</td></tr></tbody></table></figure></div><h3><span>次のステップ</span></h3><p>このワークフローをさらに発展させたい方は、以下の記事もご覧ください：</p><p><strong>📚 関連記事シリーズ</strong>:</p><ol><li><a href="https://tech-lab.sios.jp/archives/49140" target="_blank" rel="noopener" title="">Claude Code 革命！3 フェーズ開発で効率的な開発：計画 → 実装 → 検証術</a> ← 本記事の前提知識</li><li><a href="https://tech-lab.sios.jp/archives/49148" target="_blank" rel="noopener" title="">AI 協働で仕様書アレルギー克服！開発時間を 1 週間 →2 日に短縮する実践法</a> ← 3 フェーズ開発の実践例</li><li><strong>本記事</strong>: 検証 → 記事化ワークフロー（4 フェーズ目の詳細）</li></ol><p><strong>🔧 実装詳細・応用編</strong>:</p><ul><li><a href="https://tech-lab.sios.jp/archives/49157" target="_blank" rel="noopener" title="">AI と爆速開発！Next.js×Nest.js 型定義同期の自動生成パイプライン構築術</a> ← API 自動生成の実践</li></ul><p><strong>🔜 今後の予定</strong>:</p><ul><li>Claude Code× モノレポで実現する AI 協業開発環境（全体像のまとめ記事）</li></ul><h2><span>参考リンク</span></h2><h3><span>公式ドキュメント</span></h3><ul><li><a href="https://docs.claude.com/en/docs/claude-code">Claude Code 公式ドキュメント</a></li><li><a href="https://cheerio.js.org/">Cheerio 公式ドキュメント</a></li><li><a href="https://mermaid.js.org/">Mermaid 図記法</a></li><li><a href="https://www.markdownguide.org/">Markdown 記法</a></li></ul><hr><p>ここまで読んでいただき、ありがとうございました！</p><p>検証 → 記事化ワークフローを実践することで、実装完了後の知見が自然に記事化され、技術ブログの執筆が劇的に効率化されます。ぜひ、この記事を参考に、あなたのプロジェクトでも実践してみてください。</p><p>質問や感想は、コメント欄でお待ちしております。また、Twitter のほうもよろしくお願いします！</p><!-- Anyway Feedback Container //--><div>ご覧いただきありがとうございます！

<span>この投稿はお役に立ちましたか？</span><br><br><a href="#afb-post-50103">役に立った</a><a href="#afb-post-50103">役に立たなかった</a><br><br><span>0人がこの投稿は役に立ったと言っています。</span><input type="hidden" name="post_type" value="post"><input type="hidden" name="object_id" value="50103"></div><!-- //Anyway Feedback Container -->