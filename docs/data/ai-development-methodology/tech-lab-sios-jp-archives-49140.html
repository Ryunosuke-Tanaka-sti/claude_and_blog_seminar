<!--
ブログ記事情報:
タイトル: Claude Code革命！3フェーズ開発で効率的な開発：計画→実装→検証術 | SIOS Tech. Lab
URL: https://tech-lab.sios.jp/archives/49140
OGP画像: https://tech-lab.sios.jp/wp-content/uploads/2025/09/305c140bf4e96f21d94f9e46fa7b093a.png
抽出日時: 2025-11-07T20:47:49.522Z
-->

<h1>Claude Code革命！3フェーズ開発で効率的な開発：計画→実装→検証術 | SIOS Tech. Lab</h1>


	
<div data-smooth-scroll="1" data-smooth-scroll-offset="24"><div><div><b>目次</b></div><div><ul><li><a href="#hajimeni"><span>1</span><span>はじめに</span></a></li><li><a href="#AIga_einodehanaku_ren_jianga_ei"><span>2</span><span>AIが悪いのではなく、人間が悪い</span></a></li><li><a href="#cong_lai_shou_fano_xian_jiepeakodingu"><span>3</span><span>従来手法の限界：ペアコーディング</span></a><ul><li><a href="#peakodinguno_ju_ti_dena_wen_ti_dian"><span>3.1</span><span>ペアコーディングの具体的な問題点</span></a></li></ul></li><li><a href="#direkutori_gou_chengtofairu_guan_li"><span>4</span><span>ディレクトリ構成とファイル管理</span></a></li><li><a href="#xin_shou_fa3fezu_kai_fa"><span>5</span><span>新手法：3フェーズ開発</span></a><ul><li><a href="#ji_huafezu"><span>5.1</span><span>計画フェーズ</span></a></li><li><a href="#shi_zhuangfezu"><span>5.2</span><span>実装フェーズ</span></a></li><li><a href="#jian_zhengfezu"><span>5.3</span><span>検証フェーズ</span></a></li><li><a href="#shi_jino_kai_fa_xiao_guo_jing_yi_dena_shi_jian_duan_suo"><span>5.4</span><span>実際の開発効果：驚異的な時間短縮</span></a></li></ul></li><li><a href="#kono_shou_fano_xiao_guoto_xuebisoshite_ke_ti"><span>6</span><span>この手法の効果と学び、そして課題</span></a><ul><li><a href="#bagu_fa_sheng_luto_shi_yang_loureno_shi_tai"><span>6.1</span><span>バグ発生率と仕様漏れの実態</span></a></li><li><a href="#xue_xi_xiao_guono_fa_jian"><span>6.2</span><span>学習効果の発見</span></a></li></ul></li><li><a href="#shi_jiandeno_zhu_yi_diantokotsu"><span>7</span><span>実践での注意点とコツ</span></a><ul><li><a href="#kono_shou_faga_xiangiteinai_zuo_ye"><span>7.1</span><span>この手法が向いていない作業</span></a></li><li><a href="#furontoendodezainno_te_shu_xing"><span>7.2</span><span>フロントエンドデザインの特殊性</span></a></li><li><a href="#Claude_Codeno_wangrepposatono_fuki_hei_fang"><span>7.3</span><span>Claude Codeの”忘れっぽさ”との付き合い方</span></a></li><li><a href="#shi_yongni_xiangiteirupurojekuto"><span>7.4</span><span>適用に向いているプロジェクト</span></a></li></ul></li><li><a href="#matome"><span>8</span><span>まとめ</span></a></li></ul></div></div></div><h2><span>はじめに</span></h2><p>みなさん、こんばんは。最近はClaude CodeでAIにコードを書かせる検証をしている龍ちゃんです。</p><p>先月はあまりブログを書けなくて、僕もビックリするぐらい三本しか書いていませんでした。今月は多少時間を取ってでもブログを書いていこうと思っています。</p><p>まず<a href="https://tech-lab.sios.jp/archives/49136" target="_blank" rel="noopener" title="">Vibe Codingをやってみて感じた課題感</a>に関してはこちらでまとめています。</p><h2><span>AIが悪いのではなく、人間が悪い</span></h2><p>色々検証して思ったことですが、<strong>だいたい人間の入力が悪い</strong>というか、人間のせいなんですよね。AIの仕組みでそれを解消しようという試みもありますが、業務でAIを使うなら、人間の入力が悪いと考えて、入力の方を改善していく方が、AIの精度向上を待つよりも効果的だと思います。人間の入力をいかに変えていくかということにフォーカスを当てて検証を進めています。つまり、<strong>Claude Codeが悪いんじゃなく、人間が悪い</strong>んです。</p><figure><img data-recalc-dims="1" decoding="async" width="880" height="351" src="https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/9ede53a6913866faaecc3f96c087c0e2.png?resize=880%2C351&amp;ssl=1" srcset="https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/9ede53a6913866faaecc3f96c087c0e2.png?w=964&amp;ssl=1 964w, https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/9ede53a6913866faaecc3f96c087c0e2.png?resize=940%2C374&amp;ssl=1 940w" sizes="(max-width: 880px) 100vw, 880px">  (https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/9ede53a6913866faaecc3f96c087c0e2.png?resize=880%2C351&amp;ssl=1) </figure><p>人間の入力をAIが理解しやすいように作っていくという前提を押さえてもらえればと思います。</p><h2><span>従来手法の限界：ペアコーディング</span></h2><p>最初の1〜2ヶ月間、Claude Codeを使い始めた頃は、Vibe Coding（ペアコーディング）という手法で開発していました。プロンプトとしては100から300文字ぐらいのシンプルなものを投げていました。</p><p>これだと小規模な改善や機能追加には非常に優秀でした。リファクタリングも効果的でした。しかし、大規模な開発（例えば、一つのページ全体を組むような）をしようとすると、意図したとおりのものを作ってくれないことがありました。AIが自由に解釈しすぎて、変なものを作ってくることもありました。</p><h3><span>ペアコーディングの具体的な問題点</span></h3><p>実際にペアコーディング手法で開発していて気づいた課題があります。雑なプロンプトを投げて作ったものだと、やっぱり意図したものが作られないということが頻繁にありました。また、ペアプログラミング的な使い方だと人間の手が入る分、作業が遅くなるという印象もありますね。</p><p>特に既存プロジェクトで、すでにコード規約やディレクトリ構成が決まっている状態なら、それを学習させてからエンドポイントを追加する作業は割と有効だと思います。しかし、<strong>300文字程度で自分が作りたいものを説明するのは文豪でも難しいでしょう</strong>。文章が苦手な人にとっては尚更です。</p><p>ここで思い出してほしいのが「人間が悪い」ということです。そういう意味では、「意図したものができない」と言っている人は、当然のことを言っているだけなのです。</p><p>このような背景があり、リファクタリングは得意分野だと言えます。既存コードのパフォーマンス問題を改善するといった単純な指示は分かりやすいです。しかし新機能開発となると話が違います。Claude Codeで自分の意図したとおりのものを作る手法についてお話ししようと思います。</p><h2><span>ディレクトリ構成とファイル管理</span></h2><p>ディレクトリ構成としては、計画・検証用のドキュメント部分と実装コード部分を分けています。</p><div><pre><code>/
├── CLAUDE.md                    # プロジェクト全体のガイドライン
├── docs/                        # 計画・設計フェーズ
│   ├── CLAUDE.md                # 計画フェーズ専用ルール
│   ├── features/                # 新機能計画
│   ├── bugs/                    # バグ調査・修正計画
│   └── research/                # 検証結果・知見
└── application/                 # 実装フェーズ
    ├── backend/
    │   └── CLAUDE.md            # バックエンド実装ルール
    └── frontend/
      　 └── CLAUDE.md            # フロントエンド実装ルール</code></pre></div><h2><span>新手法：3フェーズ開発</span></h2><p>最近実践している方法では、開発フェーズを「<strong>計画</strong>」「<strong>実装</strong>」「<strong>検証</strong>」の3つに分けています。</p><figure><img data-recalc-dims="1" decoding="async" width="880" height="188" src="https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/9aa39f9c0c41b84adcfdaf4001292b65.png?resize=880%2C188&amp;ssl=1" srcset="https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/9aa39f9c0c41b84adcfdaf4001292b65.png?w=946&amp;ssl=1 946w, https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/9aa39f9c0c41b84adcfdaf4001292b65.png?resize=940%2C201&amp;ssl=1 940w" sizes="(max-width: 880px) 100vw, 880px">  (https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/9aa39f9c0c41b84adcfdaf4001292b65.png?resize=880%2C188&amp;ssl=1) </figure><h3><span>計画フェーズ</span></h3><p>まず「計画」フェーズでは、やりたいことの仕様書をAIに説明し、文書化してもらいます。<strong>このフェーズではコードを一切書かせません</strong>（型定義などの簡単なものは除く）。</p><figure><img data-recalc-dims="1" loading="lazy" decoding="async" width="800" height="405" src="https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/2ac05af23840a4bbf68459e76853f04f.png?resize=800%2C405&amp;ssl=1">  (https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/09/2ac05af23840a4bbf68459e76853f04f.png?resize=800%2C405&amp;ssl=1) </figure><p>AIが返してきたドキュメントを確認し、自分の意図しているものかを確認します。これによってAIが自由に解釈する余地を減らします。</p><p>計画フェーズで効果を発揮するCLAUDE.mdや具体的な手法・効果については「<a href="https://tech-lab.sios.jp/archives/49148" target="_blank" rel="noopener" title="">AI協働で仕様書アレルギー克服！開発時間を1週間→2日に短縮する実践法</a>」で紹介しています。</p><h3><span>実装フェーズ</span></h3><p>次に「実装」フェーズでは、作成した仕様書を読み込ませ、それに基づいて実装してもらいます。説明は全て計画フェーズで作った仕様書に含まれているので、それを入力として与えるだけです。</p><p>人間は監視役に徹し、AIが暴走した場合は適宜小さなプロンプトで修正します。</p><div><div><div><img data-recalc-dims="1" loading="lazy" decoding="async" src="https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/02/profile-mini.png?resize=80%2C80&amp;ssl=1" width="80" height="80"> [画像: 龍ちゃん] (https://i0.wp.com/tech-lab.sios.jp/wp-content/uploads/2025/02/profile-mini.png?resize=80%2C80&amp;ssl=1) <div>龍ちゃん</div></div><div><div><p>実装時に陥りそうな課題に関しては、「<a href="https://tech-lab.sios.jp/archives/49154" target="_blank" rel="noopener" title="">Claude Code仕様書ベースでハマる6つの落とし穴！失敗回避の備忘録</a>」でも書いています。</p><span></span><span></span></div></div></div></div><h3><span>検証フェーズ</span></h3><p>最後の「検証」フェーズでは、仕様書の不備がどこにあったか、その結果どのような変更が加えられたかを分析します。これにより実装と仕様を照らし合わせ、根拠のない編集を防止できます。実装後は人間の手で確認作業を行います。</p><p>計画と実装を比較することで、レビューした仕様書の中で不足があった分などを特定することができます。</p><div><pre><code>計画ドキュメントと実装の内容を確認して、計画と実装の差異がある点をまとめてください。</code></pre></div><p>ここで不測の指摘があるってことは、仕様書や計画が不足しているということになります。ここで学びができますね。</p><h3><span>実際の開発効果：驚異的な時間短縮</span></h3><p>この3フェーズ手法を実践してみて、開発期間は圧倒的に短縮されました。具体的な事例をご紹介しますと：</p><p><strong>小規模システムの例</strong></p><ul><li>バックエンドのエンドポイント2つ</li><li>フロントエンドの画面1つ</li><li><strong>開発時間：約30分で完了</strong></li></ul><p>作った画面は結構シンプルなシステムでしたが、エンドポイントの仕様としては単純なものでした。この規模なら、仕様書作成から実装まで含めて30分という短時間で完成します。</p><p><strong>中規模システムでの限界</strong> 一方で、バックエンドのエンドポイントが4つで、フロントエンドの画面でそれら4つのエンドポイントをいい感じに使うような中規模なものを作ろうとすると、セッションが限界になったりということがありました。この辺はタスクを分割するべきだったなと考えています。</p><h2><span>この手法の効果と学び、そして課題</span></h2><p>現在はプライベートリポジトリで検証しているため、大規模プロジェクトへの導入経験はまだありませんが、中規模程度の開発であれば強力なツールになると思います。特に<strong>プロトタイピングでは大きな力を発揮しそう</strong>です。</p><h3><span>バグ発生率と仕様漏れの実態</span></h3><p>開発時の課題として、バグというよりも<strong>仕様漏れ</strong>の方が圧倒的に多いです。仕様書を元に開発するので、仕様から漏れている内容が実装している最中やテストしている最中に気づいたりします。これは大体バグというより仕様漏れかなと思います。</p><p>ビルドが失敗するようなケースは結構あるんですが、PrettierやESLintなどのフォーマッターやリンターをちゃんと定義しておいて、その定義の下で処理してもらうようにするとある程度コードとしては綺麗になります。</p><p>ただし、ディレクトリ構成やプロジェクトのコード設計思想みたいなところを伝えていないと、fat controllerのように1ファイルに対して過剰にコードを書いてしまうみたいなことは割とありがちですね。</p><h3><span>学習効果の発見</span></h3><p>個人的に学びになった点としては、仕様書作成が苦手な私でも、AIが返してきた仕様書を見て「分かりやすい」と感じることがあります。学習的な側面でも価値があると思います。</p><p>完璧な仕様書があれば理想的ですが、そういうものは実際には存在せず、どこかに不備があるものです。だからこそ、<strong>機能ごとに段階的に仕様書を作っていくアプローチが有効</strong>だと思います。</p><p>また、検証フェーズで計画の不備を見つけるプロセスを踏むことでレビュー観点を育てることができます。レビューをする体験そのものが貴重です。</p><h2><span>実践での注意点とコツ</span></h2><p>ここにまとまり切っていない部分に関しては別途「<a href="https://tech-lab.sios.jp/archives/49154" target="_blank" rel="noopener" title="">Claude Code仕様書ベースでハマる6つの落とし穴！失敗回避の備忘録</a>」でまとめています。</p><h3><span>この手法が向いていない作業</span></h3><p>実際に検証してみて、<strong>この3フェーズ手法でも上手くいかない作業</strong>があることが分かりました。</p><p><strong>プロジェクト構造の大幅変更</strong> プロジェクトのディレクトリ構成を変えるような作業は、Claude Codeだとパスの解決なども自動でやってくれるのですが、使っている・参照しているファイルを再帰的に検索してということになるので、実際時間がかかってしまうという印象があります。</p><p><strong>簡単なリネーム作業</strong> 関数のリネームのような作業に関しては、人間の手作業の方が圧倒的に早いです。VS Codeのリファクタリング機能のようなサポート機能を使うのがいいんじゃないかなと思っています。</p><h3><span>フロントエンドデザインの特殊性</span></h3><p><strong>フロントエンドのデザインに関しては、仕様書を書いて作るというのはあまり向いていない</strong>かなと思ってます。</p><p>理由としては：</p><ul><li>フロントエンドで最初に想定していた仕様が全てを満たすことって無い</li><li>UIを文章で説明するのって結構な分量が必要</li><li>分量が増えるとAIが混乱する確率も上がる</li><li>実際に画面を見て「何か違うな」という瞬間が割とある</li><li>自分の書いている仕様と自分の頭の中にあるイメージが合ってることがあまりない</li><li>コンテキストが膨大に増えていく</li></ul><p>そのため、フロントエンドに関しては別のアプローチが必要だと考えており、別途検証を進めています。</p><h3><span>Claude Codeの”忘れっぽさ”との付き合い方</span></h3><p>実際に運用していて気づいたのですが、<strong>CLAUDE.mdにいくら設定を書いても、コンテキストを無視することが結構あります</strong>。特に長時間の作業や複雑なタスクになると、最初に設定した原則を忘れてしまうことがありますね。</p><p>そういう時の対処法として、私は以下のようなアプローチを取っています：</p><p><strong>リアルタイム修正パターン</strong> 動作を確認しながら進めて、「あ、意図した挙動をしてないな」と感じた瞬間に処理を止めます。そして、プロンプトに守ってほしい原則を改めて追加して再度実行する、という感じですね。</p><p><strong>事後確認パターン</strong> 処理が完了した後に、「あれ？原則守ってないですよね？」とClaude Codeに詰める作業も行っています。これによって、なぜその判断をしたのかを確認し、次回の改善につなげています。</p><p>この経験から学んだのは、<strong>AIも完璧ではない</strong>ということです。「人間が悪い」と言いましたが、同時にAI側の限界も理解して、適切にガードレールを設ける必要がありますね。完璧な仕様書があれば理想的ですが、そういうものは実際には存在しないのと同じように、完璧なAIも存在しません。だからこそ、人間とAIの協働において、お互いの特性を理解することが重要だと感じています。</p><h3><span>適用に向いているプロジェクト</span></h3><p>逆に、この手法が効果的なのは：</p><ul><li><strong>バックエンドのAPI開発</strong>：仕様が明確に定義しやすい</li><li><strong>データ処理ロジック</strong>：入力と出力が明確</li><li><strong>既存プロジェクトへの機能追加</strong>：コード規約やディレクトリ構成が既に決まっている</li><li><strong>プロトタイピング</strong>：完璧性よりもスピードを重視</li></ul><h2><span>まとめ</span></h2><p>私は新機能開発とバグレポートをこの二つの方法で分けて対応しています。計画段階で仕様書を挟むことで、意図したものを作れるようになります。</p><p>ただし、万能ではありません。プロジェクトの性質や作業内容によって、従来のペアコーディング手法や人間による手作業の方が効率的な場合もあります。<strong>適材適所で使い分けることが重要</strong>ですね。</p><p>皆さんも、ぜひこの3フェーズ開発手法を試してみて、自分のプロジェクトに合うかどうか検証してみてください！何か質問や改善点があれば、コメントでお聞かせください。</p><!-- Anyway Feedback Container //--><div>ご覧いただきありがとうございます！

<span>この投稿はお役に立ちましたか？</span><br><br><a href="#afb-post-49140">役に立った</a><a href="#afb-post-49140">役に立たなかった</a><br><br><span>0人がこの投稿は役に立ったと言っています。</span><input type="hidden" name="post_type" value="post"><input type="hidden" name="object_id" value="49140"></div><!-- //Anyway Feedback Container -->